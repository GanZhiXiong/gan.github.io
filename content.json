{"pages":[{"title":"","text":"Hi, I’m 干志雄. 👋 About meHere are some quick things about me: 🐭 Focus on Golang. 🤝 Love Open Source. 🍎 Love Linux and macOS. ✍️ Blog at www.ganzhixiong.com. ☎️ Please contact me by email. 🤟 My favorite singers are 黄家驹🎸（Beyond）. GitHub Stats GitHub Contribution This blog change log ✨ 🐛 ⚡️2021-09-23 修改首页为三栏。 修改文章内容为两栏，且挂件仅显示目录和最近文章。 修改 About 页面为两栏，且挂件仅显示为目录和Archives。 2021-09-20 添加 About 页面。 2021-09-15 顶部导航栏添加我使用 Docker 搭建的看板网站 Wekan 。 2021-09-13 在网站首页底部中间位置，放置备案号并链接至”http://beian.miit.gov.cn/&quot;。 2021-08-27 修复只有 gt-comment-admin 样式的背景适配了深色模式。 Author title 不从 _config.icarus.yml 配置中取，而是自定义。 2021-08-20 更新 highlight.js 版本到 11.2.0。 解决[Error] Failed to load resource: the server responded with a status of 404 (Not Found) (gitalk.css.map, line 0)。 2021-07-14 添加 Mermaid 图表支持功能并修改为透明背景样式。 2021-07-12 更新 highlightjs 版本到 11.0.1。 2021-07-01 blockquote 样式仿 GitHub。 2021-06-02 添加 gitalk 评论插件。 调整段落内文字上下间距和字体大小。 调整 `` 符号内的代码为GitHub代码样式。 2021-05-29 修改文章分类的字体颜色为链接颜色。 2021-05-27 修改 favicon.svg。 修改目录和链接的颜色，减少刺眼的颜色。 2021-05-26 修改 Dark mode 仿 GitHub 配色样式。 不显示card右下角的R + 数字。","link":"/about/index.html"}],"posts":[{"title":"这样配置Typora插入图片时的规则很好👍","text":"上图分如下两种情况： 1. 图片保存在本地 我使用的规则是插入图片时，复制图片到md所在目录的 md文件名.assets 目录中。 我只需要对本地图片使用此规则，因此勾选 对本地位置的图片应用上述规则 。 勾选 优先使用相对路径 ，使用相对路径方便将md拷贝其他电脑。 2. 图片上传到服务器Typora现在支持 YAML Front Matter了，在文章的顶部输入---然后按下Enter就会创建。或者从段落菜单中点击 YAML Front Matter 。例如： 12345678910---title: &quot;这样配置Typora插入图片时的规则很好\\U0001F44D&quot;typora-copy-images-to: uploadtoc: truedate: 2021-06-21 09:46:16tags: - Typora - PicGo - YAML Front Matter--- 而勾选 允许根据YAML设置自动上传图片 将根据YAML是否配置了 typora-copy-images-to: upload 决定是否上传图片。若需要上传图片，请添加 typora-copy-images-to: upload 配置，且配置好上传服务，上传服务建议使用PicGo，配置GitHub图床，粘贴图片后就会自动上传，简直爽的不要不要。","link":"/p/23079ada/"},{"title":"使用go-mssqldb遇到的问题","text":"如果你遇到问题，最好的方法就是阅读官方文档。 关于go-mssqldb的使用，微软写了个很好的示例：Quickstart: Use Golang to query a database in Azure SQL Database or Azure SQL Managed Instance 。 下面编写了我使用go-mssqlddb使用遇到的问题和解决方法。 问题1. Open connection failed:sql: unknown driver “mssql” (forgotten import?)1import _ &quot;github.com/denisenkom/go-mssqldb&quot; 2. Query failed:read tcp 192.168.0.4:56417-&gt;192.168.0.12:1433: read: connection reset by peer1encrypt=disable 3. 调用存储过程报错 sql: expected 0 arguments, got 1我使用的SQL Server版本是2008。百度Google始终没有找到方法，最终在issue中找到了。所以有问题还是多看README、官方文档，以及issue中查找吧！ 解决方法是Open时的参数driverName使用 sqlserver，而不是常看到的 mssql。 4. converting argument $1 type: unsupported type []interface {}, a slice of interface错误使用： 12345func f(query string, args ...interface{}) { ... res, err := db.ExecContext(ctx, query, args) ...} 正确使用： 12345func f(query string, args ...interface{}) { ... res, err := db.ExecContext(ctx, query, args...) ...}","link":"/p/df6ec4e3/"},{"title":"如何在Go中为控制台&#x2F;终端输出添加颜色","text":"许多关于 bash 的文章都建议使用看起来像\\e[39m漂亮颜色的东西，虽然这些在 bash 中工作得很好，但对于 Go 来说却是另一回事——字符串只是按原样呈现。然而，有一些库可以让您为输出着色，但是代码太臃肿了，您甚至无法找到要解决的问题的答案。 毕竟，并不是每个人都想仅仅为了颜色而导入一个库。 不使用第三方库因此，我为您带来了为您的控制台着色的最简单方法： 123456789101112131415161718192021222324252627package colorimport &quot;runtime&quot;var Reset = &quot;\\033[0m&quot;var Red = &quot;\\033[31m&quot;var Green = &quot;\\033[32m&quot;var Yellow = &quot;\\033[33m&quot;var Blue = &quot;\\033[34m&quot;var Purple = &quot;\\033[35m&quot;var Cyan = &quot;\\033[36m&quot;var Gray = &quot;\\033[37m&quot;var White = &quot;\\033[97m&quot;func init() { if runtime.GOOS == &quot;windows&quot; { Reset = &quot;&quot; Red = &quot;&quot; Green = &quot;&quot; Yellow = &quot;&quot; Blue = &quot;&quot; Purple = &quot;&quot; Cyan = &quot;&quot; Gray = &quot;&quot; White = &quot;&quot; }} 如您所知，Windows 不支持开箱即用的命令行中的颜色，因此，检查运行时init并在运行时将所有颜色设置为空字符串windows将解决此问题，而无需到处打印丑陋的字符你的控制台。 显然，有很多方法可以让它在好的 ol’ 命令提示符下工作，但由于 Windows 10 的 WSL（Linux 的 Windows 子系统）是一个东西，如果你想要漂亮的颜色，你可以使用它而无需挣扎。 用法您所要做的就是在要着色的文本之前color.YOUR_COLOR 添加并添加color.Reset在同一文本的末尾。如果您不使用 重置颜色Color.Reset，您的控制台/终端将在会话的其余部分保持相同的颜色，所以不要忘记它。 12345678910func main() { println(color.White + &quot;This is White&quot; + color.Reset) println(color.Red + &quot;This is Red&quot; + color.Reset) println(color.Green + &quot;This is Green&quot; + color.Reset) println(color.Yellow + &quot;This is Yellow&quot; + color.Reset) println(color.Blue + &quot;This is Blue&quot; + color.Reset) println(color.Purple + &quot;This is Purple&quot; + color.Reset) println(color.Cyan + &quot;This is Cyan&quot; + color.Reset) println(color.Gray + &quot;This is Gray&quot; + color.Reset)} 使用go-color库如果你更愿意使用一个库，你可以看看TwinProduction/go-color，这是一个非常轻量级的库，我厌倦了在几个项目中重新实现相同的东西： 123456789package mainimport &quot;github.com/TwinProduction/go-color&quot;func main() { println(color.Ize(color.Red, &quot;This is red&quot;)) // Or if you prefer the longer version println(color.Colorize(color.Red, &quot;This is also red&quot;))} 本文翻译自 How to add colors to your console/terminal output in Go","link":"/p/9f76eb4e/"},{"title":"Father records +","text":"c411f5515ee312ac71e1581a72fb5b7ee240a39b0c0ba967005f20c03838383daa880829527cea896213e73ea92f098eb6de7f860c427afd0fcb465adeb4c1898df523a8313c768b666d7c8dbee87368fbb797115d1b2896dee94a5216729ce1f705516fd34b847059c1cb94ae829b5931d9789c4985290d59bf14a2167ba04a2bf4b15c9ebdbd45f9e22b6028dd2be675f5e72dd5e010b9fa9e5103710f026e1b8df17a342493086fb9a971e0b2bc5defe90ac8adc9b8fa296189921f2074abc1297e82b2a9b8ac2b3d6572c2bdec092b80c3dd1fe2f6fa8849eaf2767ff39029c7c3684feb61fd2d9f47506fce3e8b3589eeb13099c08b1ebea8b845a59a1be1f44d2349dccf5de17cd2922c2933322b49c561a6bbe80ec21d2e3ff0ccd347fc4850c5bc0bc2e585db2fe88360e94d1296ac0212bbbeec5f0e0e6dc72012b8339c1c97c7530df86fc5ddaa7320cd78b149c2175f3737d4ab1c16839c17035c1269654cda4304a021f94466e517c07bf586da16de82b7f54640ec93c48bf718dabc0bbddfb5d5329343e84d0649e33bf6103eb87922579c11fd37f4d291c41618ef75523887b1f1d00bcf5cd0e2575d3088fa450852352922eef88ebde94a5a18d476f9df45a7d6a88037588d3bfbc1838310ca0224001940abc84addce0fd2a946526918a5f730396609d5b6ceaf081a2be6cf868b82c5a6dc61bb359490d5594d4ecb2feb2c5acda6805ceafbeb74c1a620317e80180a28528ad5b339ffe95deae8d61f1304e295c8bf71be32f5748a83b225488eced5b1835259d2f24fe3b14c5102db65435a4f5153d25bd6b2aa7cfa3a2923161821bb8b62186ddffd6012fe720e869f9c4f332a5722151a0638e9ea1a3c2aadab22947e94447abf2b79e4ad9319f17c947850abcdd403e5aafd67732c042c09152d1bf8cde4bc27fc8fca20295c6ae0f91a38035bc38693b5e60169a9ac22b9fc7309d27b03f1e6b53ca7291a1871c167d5ee7bae9190bd0d44086fe7ba6239792f85ecec8f682b3dd527648c74cc28e3af0a51d8cb0baa41e055bbffbb5b1fadfe48fdd781e3e5de542849cc114a87d87d93262e498b6db99a6ee42a6c82b23509fc888df3621e1c24389e2be7d931fdb21cd2d41891a739c7b68addcaa1f6fc9cf577c7c991c4c1975e7b30b8f35f031e3b720c78a2786d5328559faa1adcb513ee1f6b13e66740a0b9f0568183b0746d1fbba6fbeb833f72d500bb6bdf322d8d85daa83a907a60e493f3083345eb78c5ed8e4f70fb8ef8978b2a1baa51c729b51a357c418086fb8fc8c2d86fe55c39fcc151b6bbbb4315c41cf0e956fc79ebab1636150472753e2f883079b3ff63d8b43c78f7602e18fda25cc999f5efd91e0ccd6068045810612507b70c299106a8a259d3370707217b08508c7dcf42d0c08c07cdb4ddeb944848e72a6c7c989b6cdbadfa6103ab35392f0bac99496e5131df64e9817a77e4e77399beccecdd7d6bb7d14ff8897b41446c8aa2083daa4ccfbc6b6afe73b8bcdf8ab8328476faf36d05707bd3076b6643e70070a52e00eebe881e1d49a79502a790d55065e78b327cc7339565e5dc74be188b21106cb3b4cfead6017b151cf55d315675a6fc7e7080e18ad6b1739105713b4eb5e00648ad6b104bce8bb34f5e9110a61046c8d218365ddfd13c0a13c284909c43ace5b2bf12d769f69b7fb8c931e207fc9239d9549583c2d5cfbfcd8302ff5884c27cc5087f2ae2c9d6f63e4d5846ad10ecf7c98a96b160051a7f1d97d3b751fe2f5a1f296d42e995b01ccf93a19b3cb15a3bf330f676c4294d13ef63f2cf5193fd0bbbbcd9dae25399caf00564e313c0b1d45d9ebd8ffe6c0deac4dfb50a4d4c87abc2611d235bbc355f52442d0ec4f461309ab4f8d103c9d0cd995ef310f1ab88a5c0561310f83aad6e411d39fabd65e7593410c1ba255792a4ea5e3277f22e699ea63c6f3aace0722ba5ae7fe18f6ecc9a9d00d19d981f7763166963cb53e6ffe2030b47184a12cd6774dd7a370dac2fd923549ea63728280d693de2b07b5e963fae91d1e70666c9cc21dc261f83767f5673ca2221b215bc15d9823fb11c2987a00bfc764457adc27a83b14c079446b815c01e0a107f744c73657ceb19 Hey, password is required here.","link":"/p/c93bfabc/"},{"title":"DataTabel转换List时GetProperty反射赋值报错：从“System.String”到“System.Nullable[[System.DateTime]的强制转换无效","text":"在写代码时经常会碰见可空类型的数据段，Table转换List和List转Table时会很头疼，现在记录下解决方案。 DataTable转换为List下方代码适合所有可空类型的转换——TableToList： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static List&lt;T&gt; TableToEntity&lt;T&gt;(DataTable dt) where T : class, new() { // 定义集合 List&lt;T&gt; ts = new List&lt;T&gt;(); if (dt != null &amp;&amp; dt.Rows.Count &gt; 0) { // 获得此模型的类型 Type type = typeof(T); string tempName = &quot;&quot;; foreach (DataRow dr in dt.Rows) { T t = new T(); // 获得此模型的公共属性 PropertyInfo[] propertys = t.GetType().GetProperties(); foreach (PropertyInfo pi in propertys) { tempName = pi.Name; // 检查DataTable是否包含此列 if (dt.Columns.Contains(tempName)) { // 判断此属性是否有Setter if (!pi.CanWrite) continue; object value = dr[tempName]; if (value != DBNull.Value) { //pi.SetValue(t, value, null); // pi.SetValue(t, Convert.ChangeType(value, pi.PropertyType, CultureInfo.CurrentCulture), null); pi.SetValue(t, ChanageType(value,pi.PropertyType), null); } } } ts.Add(t); } } return ts; } //转换可空类型 如：DateTime? private static object ChanageType(object value, Type convertsionType) { //判断convertsionType类型是否为泛型，因为nullable是泛型类, if (convertsionType.IsGenericType &amp;&amp; //判断convertsionType是否为nullable泛型类 convertsionType.GetGenericTypeDefinition().Equals(typeof(Nullable&lt;&gt;))) { if (value == null || value.ToString().Length == 0) { return null; } //如果convertsionType为nullable类，声明一个NullableConverter类，该类提供从Nullable类到基础基元类型的转换 NullableConverter nullableConverter = new NullableConverter(convertsionType); //将convertsionType转换为nullable对的基础基元类型 convertsionType = nullableConverter.UnderlyingType; } return Convert.ChangeType(value, convertsionType); } List转换为DataTable下方代码为List转Table: 1234567891011121314151617181920212223242526/// &lt;summary&gt; /// 转化一个DataTable /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable ToDataTable&lt;T&gt;(IEnumerable&lt;T&gt; list) { //创建属性的集合 List&lt;PropertyInfo&gt; pList = new List&lt;PropertyInfo&gt;(); //获得反射的入口 Type type = typeof(T); DataTable dt = new DataTable(); //把所有的public属性加入到集合 并添加DataTable的列 Array.ForEach&lt;PropertyInfo&gt;(type.GetProperties(), p =&gt; { pList.Add(p); dt.Columns.Add(p.Name, p.PropertyType); }); foreach (var item in list) { //创建一个DataRow实例 DataRow row = dt.NewRow(); //给row 赋值 pList.ForEach(p =&gt; row[p.Name] = p.GetValue(item, null)); //加入到DataTable dt.Rows.Add(row); } return dt; } 但是如果实体类有可空类型的又会报错：System.NotSupportedException: DataSet 不支持 System.Nullable&lt;&gt; 解决方法： 12345678910111213141516171819202122232425262728293031323334353637public static DataTable ToDataTable&lt;T&gt;(IEnumerable&lt;T&gt; list) { try { DataTable dtReturn = new DataTable(); // column names PropertyInfo[] oProps = null; // Could add a check to verify that there is an element 0 foreach (T rec in list) { // Use reflection to get property names, to create table, Only first time, others will follow if (oProps == null) { oProps = ((Type)rec.GetType()).GetProperties(); foreach (PropertyInfo pi in oProps) { Type colType = pi.PropertyType; if ((colType.IsGenericType) &amp;&amp; (colType.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;))) { colType = colType.GetGenericArguments()[0]; } dtReturn.Columns.Add(new DataColumn(pi.Name, colType)); } } DataRow dr = dtReturn.NewRow(); foreach (PropertyInfo pi in oProps) { dr[pi.Name] = pi.GetValue(rec, null) == null ? DBNull.Value : pi.GetValue(rec, null); } dtReturn.Rows.Add(dr); } return dtReturn; } catch(Exception es) { throw es; } }","link":"/p/ee63ef96/"},{"title":"打新冠疫苗经验分享","text":"封面为我打疫苗受的伤😂，不希望大家也像我这样，因此我把经验分享给大家👍！ 5月初打第一针的时候人不多，而且包接送。 今天打第二针是需要预约的（需要通过自己所在的社区进行团队预约，目前已不支持个人预约了。），而且得抢，还不一定能抢到。我约的10点的车，在西乡社区居委会等车都等到快11才来车，原因是打疫苗的地方人太多了，即使把我们送过去，都没有地方可以站人了。到了就在那里排队等待打疫苗，等待区的地方人都站满了，想象一下大热天的站在烈日下的感觉吧。 从10点在社区居委会等车，一直到2点我才打完疫苗。整整4个小时，感觉浪费了大把时间，因此我有必要分享下我的经验： 能打的还是尽早去打吧，毕竟现在免费，会面估计早去打的话估计人更多。 我所在的社区已经不支持个人预约了（深圳），要到通过社区团队预约。 一定要约早一点，最好9点半之前，不然真的人太多了。我还以为周一大家都不会请假，没想到人特别多。 一定要带伞，既可以防晒又可以防雨。 带只笔吧。在社区需要填《知情同意书》，排队打疫苗时要填《声明书》，自己有笔可以边排队边填写。 水也带瓶吧，虽然打第二针的时候是有发水的，还是有备无患吧。 身份证一定要带。 手机充满电，手机充满电，手机充满电。","link":"/p/bb533952/"},{"title":"美的MRC1687-50G净水器滤芯附使用说明书","text":"没想到官方原装净水器滤芯竟然要这么贵！🥴🥴🥴 先附上美的官网MRC1687-50G的使用说明书。 以下表格为我整理的净水器价格。 滤芯 官方上门更换价格 官网价格 使用期限 拼多多 PP棉 88 88 4-6个月 原装全套398 前置活性炭C1 108 108 6-12个月 通用M6全套216 后置活性炭C2 108 108 6-12个月 RO反渗透 298 348 2-3年 602 652-97.80（优惠券）=554.2 我看了下美的的换滤芯说明，看着似乎没那么简单，所以建议第一次换滤芯，真的不会还是不要瞎折腾，还是找官方上门安装，顺便可以自己跟着安装师傅学学怎么安装的，毕竟净水器这玩意涉及到饮水健康。 我是预约美的官方上门更换的，由于和美的出了点意外，所以更换的时候美的免去了PP棉的费用。我是更换了全部滤芯，包括一个不知道是什么的滤芯（如下图所示），该滤芯50元，一共是88+108+108+300+50=654-88=566元。我更换滤芯日期为2021-06-21，也就是22年1月就得更换PP棉或活性炭。","link":"/p/ce2b80bc/"},{"title":"Linux上统计文件和目录个数命令详解","text":"使用Linux的时候我们经常百度或谷歌搜索命令，其实很多比较长命令我们没必要去死记它，其实你如果把长命令的每个命令分解下，就很容易记住它了。 比如统计目录下文件个数的命令 ls -l | grep &quot;^-&quot; | wc -l ，我们先分析这条命令中各个命令是什么意思，然后再推导出统计目录下目录个数的命令。 lsls是一个由POSIX和单一Unix标准规范的命令，在Unix和类Unix系统中都有实现。ls是英文list的缩写，用于列出文件，是Unix和类Unix系统中使用非常频繁的命令。 语法1ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...] 不加参数时当不加参数运行时，ls列出当前目录下的除隐藏文件外的所有文件和目录名。不加参数时，ls仅仅列出文件和目录的名称，不加任何修饰。这通常让人很难区分文件的类型、大小、权限等属性。 以目录名为参数如果以目录名作为参数，则会列出该目录下的文件。用户也可以指定多个文件和目录作为参数，ls则会列出所有指定的文件和目录中的文件名。 加 -a 参数才能显示隐藏文件如以 “.”（圆点）开头的目录在一般情况下不会被列出。用户可以加 -a 选项查看所有文件。 常用参数 -l（long）长格式，显示文件类型、权限、硬链接的数目、文件拥有者、文件所在的组、大小、日期和文件名。 -F 在不同类型的文件的文件名结尾追加一个字符以示区别。可执行文件后加”*”，目录后加”/“，管道文件后加”|”，套接字文件后加”=”，普通文件没有后缀。 -a（all）显示所有文件，包括以 . 开头的文件名（默认不显示）。 -A（all）显示所有文件，不包括以 .（自身目录）和 .. （父目录）。相关词条：Inode -R（recursive）迭代显示目录下所有的子目录。ls -R／会显示文件系统中的所有文件。 -d（directory）显示目录本身的信息，而不是列出目录下的文件。 l或ll有的系统直接输入l或ll也可以显示类似ls的效果。但是想查询 l或ll 命令使用方法，却查询不到： 原来 l或ll 是被定义好的别名（alias），别名就是赋予一条命令或者一列命令的名称。通过 alias 命令可以查询别名的具体命令，如： 查看全部别名 1234567891011121314151617181920$ alias -='cd -'...=../......=../../.......=../../../........=../../../../..1='cd -'2='cd -2'3='cd -3'4='cd -4'5='cd -5'6='cd -6'7='cd -7'8='cd -8'9='cd -9'_=sudoafind='ack -il'd='dirs -v | head -10'g=gitga='git add' 自定义别名 1vim ~/.bashrc 管道管道命令的形式是“命令1 | 命令2”，其中命令2是管道命令。 管道命令可以是查找字符串的grep命令，也可以sort这样的排序命令，也可以是wc这样的统计命令，anyway，无论是查找还是排序，抑或是统计，他们操作的对象是命令1输出的一行一行字符串。 grepgrep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。 grep这个应用程序最早由肯·汤普逊写成。grep原先是ed下的一个应用程序，名称来自于g/re/p（globally search a regular expression and print，以正则表达式进行全局查找以及打印）。在ed下，输入g/re/p这个命令后，会将所有符合先定义样式的字符串，以行为单位打印出来。 参数 -i 或 --ignore-case 忽略大小写。 -v 或 --invert-match 不显示不包括匹配文本的所有行。 列出文本中包含“hexo”的文本行 grep默认情况下是大小写敏感的，因此不会返回匹配“Hexo”的文本行。通过 -i 参数则可以忽略大小写： 1grep -i hexo package.json 列出文本中以“d”开头的文本行12$ grep '^d' .gitignore db.json 正则表达式 ^ 表示行首， “d$” 表示行首以d开头的文本行。 $ 表示行尾， “d$” 表示行尾以d开头的文本行。注意 $ 符号的位置。 [^] 匹配除 [^字符] 之外的任何一个字符。 例如9[^0]， 不会匹配90，但是会匹配91,92等。 wc**wc** （英语：word count）是在类UNIX操作系统中的一个命令。 程序从标准输入流或文件列表读取文件，并生成一个或多个下列统计信息： 文件包含的字节数、单词数以及文件的行数（也就是换行符的个数）。如果用户提供的是一个文件列表，则每个文件的单独统计和总体统计结果都会给出。 wc程序示例： 1234$ wc foo bar 40 149 947 foo 2294 16638 97724 bar 2334 16787 98671 total 第一列表示文件中的行数，以上实例表示文本文件foo有40行，并且bar文件包含2294行，总计2334行。 第二列表示文件中的单词个数：foo文件包含149个单词，且bar文件中有16638个单词，总计16787个单词。 第三列表示文件中包含的字符个数：foo文件总共有947个字符，且bar文件中有97724个字符，总计有98761个字符。 较新版本的wc可以区别比特和字符的统计。区别在于：Unicode字符集包含了多字节的字符。可以通过选择 -c 或是 -m 参数来选择所需的行为。 语法1wc [-clmw] [file ...] 参数 wc -l &lt;文件名&gt; 输出行数统计 wc -c &lt;文件名&gt; 输出字节数统计 wc -m &lt;文件名&gt; 输出字符数统计 wc -L &lt;文件名&gt; 输出文件中最长一行的长度 wc -w &lt;文件名&gt; 输出单词数统计 获取目录中文件和目录数量1ls -A | wc -l 获取目录中文件数量 方法一，匹配行首以 - 开头的文本行 1ls -lA | grep &quot;^-&quot; | wc -l 方法二，匹配行尾不以 / 结尾的文本行 1ls -AF | grep -v '/$' | wc -l 方法三，匹配行尾除了以 / 结尾的文本行 1ls -AF | grep '[^/]$' | wc -l 获取目录中的目录数量 方法一，匹配行首以 d 开头的文本行 1ls -lA | grep '^d' | wc -l 方法二，匹配行尾以 / 结尾的文本行 1ls -AF | grep '/$' | wc -l 方法三，匹配行尾以 / 结尾的文本行 1ls -AF | grep -v '[^/]$' | wc -l","link":"/p/e930dc08/"},{"title":"如何测试端口的连通性？","text":"通过命令行测试端口的连通性，可以快速帮助我们排查端口的问题，本文将介绍在macOS、Linux和Windows上如何测试端口的连通性？ Linux和Windows在Linux和Windows下，我们就直接可以用 telnet 命令来测试端口是否畅通。具体用法：telnet 指定的IP或者域名端口号。 例如： 12telnet 192.168.1.102 3306telnet 127.0.0.1 8090 需要注意的是Windows需要在 启用或关闭Windows功能 中勾选 Telnet Client 。 macOS1234567891011$ nc -vz -w 2 192.168.100.57 1433found 0 associationsfound 1 connections: 1: flags=82&lt;CONNECTED,PREFERRED&gt; outif en0 src 192.168.100.54 port 63398 dst 192.168.100.57 port 1433 rank info not available TCP aux info availableConnection to 192.168.100.57 port 1433 [tcp/ms-sql-s] succeeded!","link":"/p/bc7e18e1/"},{"title":"Microsoft Remote Desktop如何拷贝文件到Mac ？","text":"你以为Microsoft Remote Desktop通过复制、粘贴快捷键就可以将远程桌面Windows中的文件拷贝到Mac中吗？试试你就知道，这样虽然能将文件拷贝到Mac，但是却和源文件不同。 比如你在Windows上新建一个1.txt，并写入内容，选中文件，然后按下Ctrl + C，接着再Mac的Finder目录中按下Comand + V。你会发现文件虽然拷贝过来了，但是打开1.txt的内容却为空。 那么如何正确的将Windows中文件拷贝到Mac中呢？正确步骤如下： 点击编辑PC按钮。 勾选 Redirect folders。 添加要将Windows文件拷贝到Mac中的目录。比如我配置为dell目录（如上图所示）。 重新连接Windows，你就会在文件资源管理器中发现Mac共享的文件夹dell。 将要拷贝到Mac中的文件直接拷贝到共享目录dell即可。","link":"/p/8b2e9334/"},{"title":"iOS 14上UIDatePicker使用旧样式","text":"iOS一旦更新，随之而来的就是App的适配工作。其实大部分App根本不会去用iOS更新后的新特性，所以很多时候的适配都是浪费时间。所以我一再强调跨平台的重要性，注意此跨平台是指不赖原生，因此不会随着iOS更新UI发现变化。比如自绘渲染引擎的Flutter。 问题UIDatePicker在iOS 14上只显示了当天一个日期（如下图所示），且无法滚动选择其他日期。 解决在iOS13.4之后 UIDatePicker 增加了属性preferredDatePickerStyle： 123456789101112131415@available(iOS 13.4, *)public enum UIDatePickerStyle : Int { /// 这个属性会自动为当前平台和模式选择最佳样式。 case automatic = 0 /// 这个属性就是我们常用的那种滚轮的了 case wheels = 1 /// 为日期选择器使用紧凑的样式。 编辑在覆盖中进行。 case compact = 2 /// Use a style for the date picker that allows editing in place. @available(iOS 14.0, *) case inline = 3} 使用如下代码将该属性为 wheels 即可： 123if (@available(iOS 13.4, *)) { _datePicker.preferredDatePickerStyle = UIDatePickerStyleWheels;}","link":"/p/f569bd/"},{"title":"如何让我的网站被Google收录更多？","text":"建站一个月了，发现在谷歌中的收录有点少，我将网站添加到谷歌搜索控制台后，仅仅过去16个小时，收录就增加了83个网址。 对于 hexo 博客来说，如果你是部署在 GitHub Pages，那么你是无法被百度收录的，因为 GitHub 禁止了百度爬虫，最常见的解决办法是双线部署到 Coding Pages 和 GitHub Pages，因为百度爬虫可以爬取到 Coding 上的内容，从而实现百度收录，如果你的 hexo 博客还没有实现双线部署，请参考：《Hexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS》，另外百度收录的所需的时间较长，大约半个月左右才会看到效果！ 以后有时间了在实现双线部署，因此我也仅在 百度搜索资源平台 中添加了本网站和 sitemap ，仅仅做这些不知道能否被百度收录还有待观察。（在百度搜索资源平台中添加网站和谷歌相似，看了本文估计你也会了，因此不再复述。） 添加前使用 site:域名 查看网站是否被收录，我的博客搭建了有差不多一个月了，之前也没提交过网站到谷歌搜索控制台，不过谷歌爬虫的确是强大，即使没有提交过，现在也能看到39条结果了： 将网站添加到谷歌搜索控制台 打开 谷歌搜索控制台。 添加资源。 选择资源类型，输入域名或网址。 有两种验证方式，分别是网域和网址前缀，两种资源类型区别如下： 由对比可知选择网域资源验证方式比较好，只需要一个域名就可以匹配到多种格式的 URL 验证域名所有权。 就是验证这个域名是不是属于你的。 推送网站中网址链接上面步骤完成后，还需要推送网址链接给谷歌。推送网址链接有两种形式： 单独逐条添加 以站点地图添加，google会隔一段时间抓取站点地图中的网址链接 建议采用站点地图的形式添加，一劳永逸，除非有些网址不在站点地图中，我们才采用单独添加。 安装 hexo-generator-sitemap在blog根目录npm下载生成站点地图插件： 1npm install hexo-generator-sitemap --save 然后每次hexo g后都会在public根目录生成一个sitemap.xml文件，揪下来我们将该文件的网址链接提交给google站点，就ok了。 添加站点地图网址 添加后添加后仅仅过去16个小时，网站在谷歌中的收录就从39上升到122，收录增加了83个网址。","link":"/p/c55658d2/"},{"title":"如何修改gitalk的CSS样式","text":"icarus主题是自带评论插件的，评论插件由ppoffice/hexo-component-inferno提供。具体启用评论插件的操作请看 Icarus用户指南 - 用户评论插件。 我启用了Gitalk作为评论插件，Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。但是其默认是浅色模式，而我的博客是深色模式，这样配色就很不协调了。因此我需要将Gitalk的浅色模式改为和我博客一致的深色模式。 步骤修改CSS文件修改CSS文件有两种方法。 方法一：直接在gitalk.js中修改 打开你博客目录下的 node_modules/hexo-component-inferno/lib/view/comment/gitalk.js 文件。 找到 cssUrl: helper.cdn('gitalk', '1.7.2', 'dist/gitalk.css'), 将其注释。在其下行添加 cssUrl: '/css/gitalk.css', 。 gitalk.js12345678910111213141516171819202122232425Gitalk.Cacheable = cacheComponent(Gitalk, 'comment.gitalk', function (props) { var helper = props.helper, comment = props.comment; // FIXME: config name change var id = crypto.createHash('md5').update(props.page.path).digest('hex'); return { id: id, repo: comment.repo, owner: comment.owner, admin: comment.admin, clientId: comment.client_id, clientSecret: comment.client_secret, createIssueManually: comment.create_issue_manually, distractionFreeMode: comment.distraction_free_mode, pagerDirection: comment.pager_direction, perPage: comment.per_page, proxy: comment.proxy, flipMoveOptions: comment.flip_move_options, enableHotKey: comment.enable_hotkey, language: comment.language, // cssUrl: helper.cdn('gitalk', '1.7.2', 'dist/gitalk.css'), cssUrl: '/css/gitalk.css', jsUrl: helper.cdn('gitalk', '1.7.2', 'dist/gitalk.min.js') };}); 方法二：在_config.icarus.yml中配置 打开 _config.icarus.yml。 在 comment 下添加 cssUrl ，值为 '/css/gitalk.css'。 12comment: cssUrl: '/css/gitalk.css' 打开你博客目录下的 node_modules/hexo-component-inferno/lib/view/comment/gitalk.js 文件。 找到 cssUrl: helper.cdn('gitalk', '1.7.2', 'dist/gitalk.css'), 将其注释。在其下行添加 cssUrl: comment.cssUrl, 创建gitalk.css 在此你博客目录下创建此文件 themes/icarus/source/css/gitalk.css 。 通过浏览器的DevTools工具调整gitalk的CSS后，拷贝gitalk.css的内容到 themes/icarus/source/css/gitalk.css中。 重新生成执行 hexo g 重新生成静态文件。打开生成的静态文件，可以看到css文件路径变化了。","link":"/p/89673c2d/"},{"title":"使用hexo-abbrlink插件生成永久短链接","text":"为了解决Hexo默认生成的链接，在修改文件名后，链接会跟这变，如果旧链接在其他地方有被引用，访问旧链接的响应为404错误。且链接为日期 + 目录，层级太多，不利于SEO。 因此急需一种生成永久短链接的方案！ 生成链接的默认配置1permalink: ':year/:month/:day/:title/' :title 指的是文章在_posts目录下的相对路径，不包含文件名后缀。 该配置会生成像下面这样的链接： 文章在_posts目录下 1http://localhost:4000/2021/05/24/hello-world/ 文章在_posts/git目录下 如果文件名为中文，复制的URL是URL编码后的URL，这样不仅显示得很长，不易阅读，而且还不不易于SEO（通常搜索引擎只会爬取URL前三层）。 1http://localhost:4000/2021/05/24/git/Git%20LFS%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%981/ 缺陷 修改文件名后，链接会跟这变。如果旧链接在其他地方有被引用，访问旧链接的响应为404错误。 日期 + 目录，层级太多，不利于SEO。 hexo-abbrlink安装直接看hexo-abbrlink的 README。 配置你可以使用README中的配置。 下面是我的配置： 12345678910111213141516171819# permalink: ':year/:month/:day/:title/'# 生成的文件在public目录下面# permalink: :abbrlink/# 生成的文件在p目录下面permalink: p/:abbrlink/# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex drafts: false #(true)Process draft,(false)Do not process draft. false(default) # Generate categories from directory-tree# depth: the max_depth of directory-tree you want to generate, should &gt; 0auto_category: enable: true #true(default) depth: #3(default) over_write: false auto_title: true #enable auto title, it can auto fill the title by pathauto_date: false #enable auto date, it can auto fill the date by time todayforce: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. 配置完成后先执行 hexo clean ，然后执行 hexo g 重新生成。 它会在每篇MarkDown的front matter中添加 abbrlink，例如： 123456789101112---title: 使用hexo-abbrlink插件生成永久短链接typora-copy-images-to: uploadcategories: - Blog - Hexoabbrlink: fcaf5192date: 2021-06-01 12:52:35tags: - Blog - Hexo--- 我的配置生成的链接如下： 12http://localhost:4000/p/bb533952/http://localhost:4000/p/5a8bb790/ 问题此插件我也发现了一个问题：如果没有title，生成的abbrlink为’0’ #56。","link":"/p/fcaf5192/"},{"title":"解决 Hexo 摘要页面的字体几乎全部变成了斜体","text":"09篇文章显示却没有问题，而之后的文章都显示为斜体了，打开09篇文章，发现是由于摘要标签 &lt;!--more--&gt; 设置了斜体导致的。 解决办法，去掉斜体即可。","link":"/p/8b2eb142/"},{"title":"SQL Server 2008数据库创建用户只读权限的两种方式","text":"在SQL Server 2008中，为了保护数据库的安全，需要给不同的使用者开通不同的访问用户，那么如何简单的控制用户的权限呢？下面我们就创建一个只读用户，给大家学习使用。 一、命令行方式创建新建查询窗口，然后输入以下命令然后执行即可： 123sp_addlogin 'test','test','DB' &gt;&gt;登录名、密码、登录的数据库sp_grantdbaccess 'test' &gt;&gt;将数据库用户加入到当前数据库grant select/update/delete on TABLEA/VIEWB to test &gt;&gt;给该用户赋予查询/更新/删除 表TABLEA的权限或试图VIEWB的权限 二、传统软件视窗创建 首先打开【Microsoft SQLServer Management Studio】，用管理员账户登录。 选择安全性-&gt;登录名-&gt;右键新建登录名。 在常规里输入用户名和密码。 在”用户映射”里“映射到此登录名的用户”选择该用户可以操作的数据库。 在“数据库角色成员身份”里选择“public”和”db_datareader”。 这样一个只读用户就创建完成了。 本文转载自https://blog.csdn.net/enweitech/article/details/47393657。","link":"/p/98b91355/"},{"title":"如何在macOS上安装SQL Server ?","text":"SQL Server是不能直接安装在macOS上的，但是从SQL Server 2017开始，支持了Linux，因此可以通过Docker使其在macOS上运行。 步骤1. 安装Docker在macOS上如何安装Docker请看官方文档 Install Docker Desktop on Mac。官方文档写的很详细，这里我就不介绍了。 2. 拉取 SQL Server 镜像执行如下命令拉取 SQL Server 镜像: bash1sudo docker pull mcr.microsoft.com/mssql/server:2017-latest 3. 使用 SQL Server 镜像创建并运行容器执行如下命令使用 mcr.microsoft.com/mssql/server:2017-latest 镜像，创建一个名称为 sqlserver 的容器，该容器的端口为1433。 123sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=Passw0rd&quot; \\ -p 1433:1433 --name sqlserver \\ -d mcr.microsoft.com/mssql/server:2017-latest -e &quot;ACCEPT_EULA=Y&quot; 将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 -e &quot;SA_PASSWORD=Passw0rd&quot; 指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 -p 1433:1433 将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 --name sqlserver 为容器指定一个自定义名称，而不是使用随机生成的名称。 如果执行上述命令报错了，可以通过执行 docker logs 命令检查错误日志。 4. 查看容器是否运行1docker ps 5. 在容器内连接SQL Server（可选） 使用 docker exec -it 命令在运行的容器内部启动交互式 `Bash Shell: 1sudo docker exec -it sqlserver &quot;bash&quot; sql1 是在创建容器时由 –name 参数指定的名称。 在容器内部使用 sqlcmd 进行本地连接。 默认情况下，sqlcmd 不在路径之中，因此需要指定完整路径。 1/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;Passw0rd&quot; 如果成功，应会显示 sqlcmd 命令提示符 1&gt;。 6. 利用Navicat可视化工具连接Sql Server","link":"/p/9d314fb4/"},{"title":"SQL Server如何生成表结构和数据的脚本?","text":"在想要在开发环境中复现生成环境中的问题，我们可能需要备份生产环境的数据库到开发环境进行测试，但是往往生成环境的中的数据库很大，备份会很慢，其实往往只是在访问某个表时才出现此问题，也仅仅只需要此表即可。 因此我们需要使用一种方法来导出生产环境指定表的结构和数据的脚本，然后在开发环境执行该脚本，即可得到生产环境的数据。 那么SQL Server是否提供此功能呢？ 答案是，不啰嗦，直接介绍步骤： 选择数据库，右键选择任务，点击生成脚本。 选择要生成脚本的表。 点击高级，配置 要编写脚本的数据类型 为 架构和数据。 完成上述步骤，即可导出表结构和数据的脚本。","link":"/p/f1f1706b/"},{"title":"如何正确的将字符串数组传给in","text":"问题C#使用join将数组的元素用逗号分隔为字符串传递给SQL Server存储过程要么报错，要么查询的表格结果为0条数据。 C#中的代码如下： 1234DataTable dataTable = DbHelperSQL.RunProcedure(&quot;proc_Data_GetUploadInfo&quot;, new IDataParameter[] { new SqlParameter(&quot;@BillCodes&quot;, $&quot;'{string.Join(&quot;','&quot;, result.Select(x =&gt; x.prepare_num.ToString()).ToArray())}'&quot;), }, &quot;get&quot;).Tables[0]; 解决经过各种尝试，我使用 exec sp_executesql @sql 这种方式解决的: 1234declare @sql nvarchar(max)set @sql='select * from (select BillCode,BillType,NetWeight,Tare,TareWeightTime,GrossWeight,GrossWeightTime from OrderInfo union select BillCode,BillType,NetWeight,Tare,TareWeightTime,GrossWeight,GrossWeightTime from EndInfo) as u where u.BillCode in('+@BillCodes+')'exec sp_executesql @sql 如果你有更好的方法，请在评论区留言。","link":"/p/5a8bb790/"},{"title":"SQL Server字符串拼接的结果为NULL的问题","text":"问题某个存储过程的参数有一个输出参数：@msg nvarchar(1024) output ，拼接的字符串会赋值给@msg，然后C#代码获取@msg后显示到界面上。 通过测试后发现字符串和变量拼接竟然变成了空字符串： 1234567declare @msg nvarchar(512)declare @name varchar(50)set @name='gan'declare @time datetime-- CONVERT(varchar,@time,20)是将时间格式化输出set @msg= 'test: ' + CONVERT(varchar,@time,20) + CAST(@name as varchar)select '1' + @msg + '2' 解决本以为使用convert和cast将类型转换为varchar字符类型就没有问题了。 检查发现，是由于@time为NULL导致的(变量声明之后的默认值为NULL)。 解决办法就是使用 isnull 将为NULL的变量转换为空字符串： 1234567declare @msg nvarchar(512)declare @name varchar(50)set @name='gan'declare @time datetimeselect @timeset @msg= 'test: ' + CONVERT(varchar,ISNULL(@time, ''),20) + CAST(ISNULL(@name, '') as varchar)select '** ' + @msg + ' **'","link":"/p/93f760c5/"},{"title":"Git LFS使用遇到的问题","text":"1. this exceeds GitHub’s file size limit of 100.00MB对于大型文件的版本控制，我按照https://git-lfs.github.com/ 操作后，还是提示下图error： 接着我运行命令git lfs track ，该命令的作用是显示 Git LFS 当前正在跟踪的所有模式的列表（以及它们在其中定义的.gitattributes 文件）。 果然这个路径是不对的，而且多出了 [[:space:]]。 解决 可以直接删除 .gitattributes文件或使用 git lfs untrack path不跟踪指定大文件。 重新执行 git lfs track EzvizLIB/libEZOpenSDK.a跟踪该文件。 再次查看跟踪文件列表。 再次push，问题解决。 2. clone下拉又LFS跟踪的文件大小只有134字节 通过搜索得知： 在安装 Git LFS 之前，克隆了使用 Git LFS 的仓库，则被 Git LFS 管理的文件会被显示为文本指针，而非具体的文件。 查看这些文件指针，会发现类似如下内容 version https://git-lfs.github.com/spec/v1 oid sha256:4b99dbe6fe6f646b2026de93481045bbf34f995559db15fce34d192f1f320ef4 size 156154 解决办法就是，手动执行获取 Git LFS 对象的命令： git lfs fetch git lfs checkout # 或 git lfs pull 解决 在一篇文章 https://zzz.buzz/zh/2016/04/19/the-guide-to-git-lfs/找到可疑方法，如下图所示： 于是执行如下命令： 1git lfs pull 执行后提示如下： 根据上一步提示，很明显没有安装lfs。从 https://git-lfs.github.com/或binary packages 下载二进制包，下载解压后，执行 .install.sh安装lfs。 再次执行 sudo git lfs pull (不加sudo，会提示无权限)，提示如下图所示： fetch失败，我想应该是网络问题，于是给终端添加代理后（注意添加后sudo命令默认是不会走代理的，因此你还需要让sudo命令走代理，方法自行搜索），再次执行 sudo git lfs pull 还是提示上图的错误。执行不带sudo的 git lfs pull 却能下载成功，但是提示 permission denied : 于是尝试重新clone却可以了。 3. 收到 At 80% of Git LFS data quota for GanZhiXiong这样的邮箱邮箱内容为： We wanted to let you know that you’ve used 80% of your data plan for Git LFS on your personal account GanZhiXiong. No immediate action is necessary, but you might want to consider purchasing additional data packs to cover your bandwidth and storage usage: https://github.com/account/billing/data/upgrade Current usage as of 21 May 2021 09:54AM UTC: Bandwidth: 0.89 GB / 1 GB (89%) Storage: 0.22 GB / 1 GB (22%) 翻译过来为： 谨在此告知您，您的个人帐户GanZhiXiong已将80％的数据计划用于Git LFS。 无需立即采取措施，但是您可能要考虑购买其他数据包来覆盖您的带宽和存储使用情况： https://github.com/account/billing/data/upgrade 截至2021年5月21日UTC的当前使用情况： 带宽：0.89 GB / 1 GB（89％） 储存空间：0.22 GB / 1 GB（22％） 你可以在 https://github.com/settings/billing 此页查看到LFS的可用存储空间和带宽： 通过 https://docs.github.com/cn/github/managing-large-files/versioning-large-files/about-storage-and-bandwidth-usage 此页可以得知GitHub为每个使用 Git Large File Storage 的帐户都会获得 1 GB 的免费存储空间和一个月的免费带宽 1 GB。 如果带宽和存储配额不够，您可以选择为 Git LFS 购买额外配额。 你可以 https://github.com/account/billing/data/upgrade 此页购买Git LFS额外配额。","link":"/p/448598ca/"},{"title":"关于GoLand创建项目勾选index entire GOPATH导致的问题","text":"使用GoLand创建项目默认是勾选 Index entire GOPATH 的 。下面分别介绍勾选或不勾选 Index entire GOPATH 的区别。 创建项目时勾选index entire GOPATH勾选index entire GOPATH会导致创建出来的项目不能导自定义的包和函数： GOPATH的配置： 创建项目时不勾选index entire GOPATH和勾选报错是一样的。 GOPATH配置： 如何解决不能导自定义的包和函数的问题 打开GOPATH配置。 Project GOPATH添加当前项目所在的路径。 经过测试只要配置了Project GOPATH，够不够选 Use GOPATH that's defined in system environment 和 Index entire GOPATH 都能成功导入自定义包和函数了。","link":"/p/14f74a7e/"},{"title":"Windows上有没有类似tail -f这样的命令？","text":"很多时候我们要监听日志文件的演变，在Linux或Unix上可以通过 tail -f filename 命令把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 那么在Windows上有没有类似命令呢？ 使用PowerShell实现你可以使用 Get-Content 或 cat 命令实现 tail -f 的功能。 使用Get-Content命令1Get-Content filename.log -Wait 可以将 Get-Content 缩短为gc。 但是该命令是将filename.log整个文件显示到标准输出。那我想显示最后n行或从n行显示到最后该怎么做呢？别急我们先看看tail是如何实现的。 tail显示最后n行tail -f 是默认显示文件最后10行，如果再加上 -n 参数，则可指定显示文件的尾部的行数。如下面这条命令表示显示文件最后3行，并动态显示追加内容： 1tail -n 3 -f ~/Downloads/1 或： 1tail -n -3 -f ~/Downloads/1 当然你可以省略 -n，也就是： 1tail -3 -f ~/Downloads/1 tail从n行显示到最后如果我想从第3行开始显示到最后呢？可使用如下命令： 1tail -n +3 -f ~/Downloads/1 或： 1tail +3 -f ~/Downloads/1 可见这些操作使用tail命令时多么的方便呀！ Get-Content显示最后n行如显示最后3行，使用如下命令： 1gc filename.log -tail 3 -Wait 使用git-bash实现首先git-bash从https://gitforwindows.org/安装 接下来，git-bash使用 Windows 路径并重新启动您的工作站： 1setx path &quot;%path%;C:\\Program Files\\Git\\bin\\&quot; 现在，您应该能够使用tail -n 20 -F logging_file.log尾随任何文件并显示最后 20 行。 参考 Is there an equivalent of tail -f on Windows?","link":"/p/73f53bd4/"},{"title":"解决PowerShell中文乱码","text":"使用PowerShell打开文本，文本里面有中文显示乱码。我尝试了几种方法，都不行，最终通过开启**Beta版：使用Unicode UTF-8提供全球语言支持(U)**解决。 以下方法对我不行，你也可以试下方法一：修改PowerShell编码格式为UTF-8查看PowerShell的当前编码格式： 1checp 临时修改PowerShell编码格式为UTF-8： 1chcp 65001 此设置只对当前终端有效，重新开启powershell终端则恢复GBK编码，若想永久修改PowerShell编码格式UTF-8，快捷键win+R输入regedit进入注册表，找到[HKEY_CURRENT_USER\\Console\\CodePage]，修改其值为65001。 方法二：PowerShell配置文件中添加OutputEncoding查看PowerShell配置文件所在的位置： 1$PROFILE 在该配置文件中添加如下配置： 1$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding 对我有效的方法 打开控制面板，点击区域。 点击更改系统区域设置。 勾选 Beta版：使用Unicode UTF-8提供全球语言支持(U) 重启电脑。","link":"/p/f1b9f4fc/"},{"title":"An error was encountered while attempting to communicate with this device. (The service is…droid","text":"Xcode真机调试报错如下图所示： Build没有问题，Install也没有问题，就是App不能启动。 点击Details，详细信息显示如下： 经搜索发现是因为使用Xcode 11真机调试iOS 14是不行的。 解决方法就是升级Xcode 11到Xcode 12。","link":"/p/8e1fc01c/"},{"title":"A valid provisioning profile for this executable was not found","text":"问题 使用Xcode Version 12.5 (12E262)安装App到iPhone失败，错误提示为：A valid provisioning profile for this executable was not found.。详情如下图所示： 解决 点击 File -&gt; Project Settings… 将Build System修改为 Legacy Build System（Deprecate）（遗留的构建系统(反对)） 从警告提示可以看出，Legacy Build System 将会被移除，不建议使用。暂时先这么，这个问题后面再解决！","link":"/p/3eabba2e/"},{"title":"The certificate used to sign YoSmart-Beta has either expired or has been revoked. An updated certificate is required to sign and install the application.","text":"iOS开发真机调试的Run时候报错 The certificate used to sign &quot;YoSmart-Beta&quot; has either expired or has been revoked. An updated certificate is required to sign and install the application.。但是Build是成功的。 然后我到钥匙串中查看此证书，竟然提示 证书不受信任 ： 然后Google到是缺少一个证书：Worldwide Developer Relations - G3 (Expiring 02/20/2030 00:00:00 UTC) 。点这里下载安装此证书。 果然，安装此证书后，开发证书就变成有效的了：","link":"/p/5b8d378e/"},{"title":"macOS、Linux安装Zsh和Oh My Zsh教程","text":"前言Linux系统提供多种不同的Shell以供选择。常用的有 Bourne Shell（简称sh）、C-Shell（简称csh）、Korn Shell（简称ksh）和 Bourne Again Shell （简称 bash ）等。对于经常使用终端的用户，我推荐大家都安装Zsh，因为体验更好。 Zsh什么是ZshZsh官网是这么介绍的 Zsh is a shell designed for interactive use, although it is also a powerful scripting language. More information can be found on the “Zsh Web Pages” sites.Zsh是一种为交互使用而设计的shell，尽管它也是一种强大的脚本语言。更多信息可在“Zsh网页”网站上找到。 Zsh Web Pages是这么介绍的 Zsh is a shell designed for interactive use, although it is also a powerful scripting language. Many of the useful features of bash, ksh, and tcsh were incorporated into Zsh; many original features were added. The introductory document details some of the unique features of Zsh. It assumes basic knowledge of the standard UNIX shells; the intent is to show a reader already familiar with one of the other major shells what makes Zsh more useful or more powerful. This document is not at all comprehensive; read the manual entry for a description of the shell that is complete, concise and up-to-date, although somewhat overwhelming and devoid of examples. Alternatively, the user guide offers wordy explanations of many of the shell’s features. If you want to read something that has been polished by a professional editor you can buy the book.Zsh是一种为交互使用而设计的shell，尽管它也是一种功能强大的脚本语言。bash、ksh和tcsh的许多有用特性都被合并到Zsh中;添加了许多原始的特性。介绍性文档详细介绍了Zsh的一些独特特性。它假定您具有标准UNIX shell的基本知识;其目的是向已经熟悉其他主要shell之一的读者展示使Zsh更有用或更强大的原因。这份文件一点也不全面;阅读手册条目，了解完整、简洁和最新的shell描述 Zsh也称为Z shell，是Bourne Shell（sh）的扩展版本，具有大量新功能，并支持插件和主题。 由于它基于与Bash相同的shell，因此Zsh具有许多相同的功能，并且切换是轻而易举的。 Zsh主要功能 自动cd：只需输入目录的名称即可 递归路径扩展：例如“/ u / lo / b”扩展为“/ usr / local / bin” 拼写更正和近似完成：如果您输入目录名称时出现轻微错误，Zsh将为您解决此问题 插件和主题支持： Zsh包含许多不同的插件框架 Linux安装Zsh 查看下剩余空间12345678[admin@Main ~]$ df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 29G 8.5G 78% /devtmpfs 1.9G 0 1.9G 0% /devtmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs 1.9G 185M 1.7G 10% /runtmpfs 1.9G 0 1.9G 0% /sys/fs/cgrouptmpfs 380M 0 380M 0% /run/user/1000 查看Linux信息123456[admin@Main ~]$ lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.0.1406 (Core) Release: 7.0.1406Codename: Core 查看当前使用的Shell12[admin@Main ~]$ echo $SHELL/bin/bash 查看安装的Shell123456789[admin@Main ~]$ cat /etc/shells /bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh 可以看到CentOS7默认没有安装Zsh 安装Zsh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[admin@Main ~]$ sudo yum install zsh[sudo] password for admin: Loaded plugins: langpacksRepodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fastbase | 3.6 kB 00:00:00 epel | 4.7 kB 00:00:00 extras | 2.9 kB 00:00:00 https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/repodata/repomd.xml: [Errno 12] Timeout on https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/repodata/repomd.xml: (28, 'Operation timed out after 3024 milliseconds with 0 out of 0 bytes received')Trying other mirror.mongodb-org-3.4 | 2.5 kB 00:00:00 updates | 2.9 kB 00:00:00 (1/8): epel/x86_64/group_gz | 95 kB 00:00:00 (2/8): epel/x86_64/updateinfo | 1.0 MB 00:00:00 (3/8): base/7/x86_64/group_gz | 153 kB 00:00:00 (4/8): base/7/x86_64/primary_db | 6.1 MB 00:00:00 (5/8): epel/x86_64/primary_db | 6.9 MB 00:00:00 (6/8): extras/7/x86_64/primary_db | 206 kB 00:00:00 (7/8): updates/7/x86_64/primary_db | 3.8 MB 00:00:00 (8/8): mongodb-org-3.4/7/primary_db | 99 kB 00:00:02 Resolving Dependencies--&gt; Running transaction check---&gt; Package zsh.x86_64 0:5.0.2-34.el7_8.2 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved========================================================================================================================================================= Package Arch Version Repository Size=========================================================================================================================================================Installing: zsh x86_64 5.0.2-34.el7_8.2 updates 2.4 MTransaction Summary=========================================================================================================================================================Install 1 PackageTotal download size: 2.4 MInstalled size: 5.6 MIs this ok [y/d/N]: yDownloading packages:zsh-5.0.2-34.el7_8.2.x86_64.rpm | 2.4 MB 00:00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : zsh-5.0.2-34.el7_8.2.x86_64 1/1 Verifying : zsh-5.0.2-34.el7_8.2.x86_64 1/1 Installed: zsh.x86_64 0:5.0.2-34.el7_8.2 Complete! 查看Zsh是否已安装12345678910[admin@Main ~]$ cat /etc/shells/bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh/bin/zsh 切换到Zsh1234[admin@Main ~]$ chsh -s /bin/zshChanging shell for admin.Password: Shell changed. reboot12345678[admin@Main ~]$ reboot==== AUTHENTICATING FOR org.freedesktop.login1.reboot ===Authentication is required for rebooting the system.Authenticating as: rootPassword: ==== AUTHENTICATION COMPLETE ===Connection xxx closed by remote host.Connection to xxx closed. 重启在进入Linux，提示如下信息：1234567891011121314151617This is the Z Shell configuration function for new users,zsh-newuser-install.You are seeing this message because you have no zsh startup files(the files .zshenv, .zprofile, .zshrc, .zlogin in the directory~). This function can help you with a few settings that shouldmake your use of the shell easier.You can:(q) Quit and do nothing. The function will be run again next time.(0) Exit, creating the file ~/.zshrc containing just a comment. That will prevent this function being run again.(1) Continue to the main menu.--- Type one of the keys in parentheses --- 按 1 进入主菜单然后提示如下信息： 1234567891011121314151617181920Please pick one of the following options:(1) Configure settings for history, i.e. command lines remembered and saved by the shell. (Recommended.)(2) Configure the new completion system. (Recommended.)(3) Configure how keys behave when editing command lines. (Recommended.)(4) Pick some of the more common shell options. These are simple &quot;on&quot; or &quot;off&quot; switches controlling the shell's features. (0) Exit, creating a blank ~/.zshrc file.(a) Abort all settings and start from scratch. Note this will overwrite any settings from zsh-newuser-install already in the startup file. It will not alter any of your other settings, however.(q) Quit and do nothing else. The function will be run again next time.--- Type one of the keys in parentheses --- 直接输入一个 0 会在 ～ 目录下生成一个空的 .zshrc 配置文件。然后提示如下信息： 1234567891011The function will not be run in future, but you can runit yourself as follows: autoload -Uz zsh-newuser-install zsh-newuser-install -fThe code added to ~/.zshrc is marked by the lines# Lines configured by zsh-newuser-install# End of lines configured by zsh-newuser-installYou should not edit anything between these lines if you intend torun zsh-newuser-install again. You may, however, edit any other partof the file. 查看是否切换为Zsh 12 [admin@Main]~% echo $SHELL/bin/zsh Oh My Zsh什么是Oh My Zsh首先看下Oh My Zsh 官网的介绍 Oh My Zsh is an open source, community-driven framework for managing your zsh configuration. Sounds boring. Let’s try again. Oh My Zsh will not make you a 10x developer…but you may feel like one. Once installed, your terminal shell will become the talk of the town or your money back! With each keystroke in your command prompt, you’ll take advantage of the hundreds of powerful plugins and beautiful themes. Strangers will come up to you in cafés and ask you, “that is amazing! are you some sort of genius?” Finally, you’ll begin to get the sort of attention that you have always felt you deservedOh My Zsh是一个用于管理Zsh配置的开源、社区驱动的框架。听起来无聊。让我们再试一次。哦，我的Zsh不会让你成为一个10倍的开发人员…但你可能觉得自己就是。一旦安装，您的终端外壳将成为讨论城镇或您的钱回来!在命令提示符中的每一次按键，您将利用数百个强大的插件和美丽的主题。在咖啡馆里，陌生人会走到你面前问你:“太棒了!”你是什么天才吗?”最后，你会开始得到你一直认为自己应该得到的关注 简单来说就是配置很麻烦，Oh My Zsh这个框架开源简化Zsh的配置，并且提供了Plugins、Community、Themes 下图为官网介绍的Oh My Zsh三大功能 安装Oh My Zsh官方提供了两种安装方式 通过curl1sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 通过weget1sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; 我这里使用curl安装123456789101112131415161718192021222324252627[admin@Main]~% sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;Cloning Oh My Zsh...Cloning into '/home/admin/.oh-my-zsh'...remote: Enumerating objects: 1156, done.remote: Counting objects: 100% (1156/1156), done.remote: Compressing objects: 100% (1124/1124), done.remote: Total 1156 (delta 21), reused 1067 (delta 16), pack-reused 0Receiving objects: 100% (1156/1156), 775.41 KiB | 16.00 KiB/s, done.Resolving deltas: 100% (21/21), done.Looking for an existing zsh config...Found ~/.zshrc. Backing up to /home/admin/.zshrc.pre-oh-my-zshUsing the Oh My Zsh template file and adding it to ~/.zshrc. __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \\/ __ \\ / __ `__ \\/ / / / /_ / / ___/ __ \\/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\\____/_/ /_/ /_/ /_/ /_/\\__, / /___/____/_/ /_/ /____/ ....is now installed!Before you scream Oh My Zsh! please look over the ~/.zshrc file to select plugins, themes, and options.• Follow us on Twitter: https://twitter.com/ohmyzsh• Join our Discord server: https://discord.gg/ohmyzsh• Get stickers, shirts, coffee mugs and other swag: https://shop.planetargon.com/collections/oh-my-zsh 安装前和安装后对比这里以ll命令来对比很明显能够看出变化了 安装zsh-syntax-highlighting语法高亮插件 Clone this repository in oh-my-zsh’s plugins directory1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting Activate the plugin in ~/.zshrc:1vim ~/.zshrc plugins添加zsh-syntax-highlighting1234plugins=( git, zsh-syntax-highlighting) 执行source ~/.zshrc 相较于纯白字的命令，添加这个插件后，现在我们的命令语法高亮了 安装zsh-autosuggestions历史记录插件 Clone this repository in oh-my-zsh’s plugins directory1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions Activate the plugin in ~/.zshrc:1vim ~/.zshrc plugins添加zsh-autosuggestions12345plugins=( git, zsh-syntax-highlighting, zsh-autosuggestions) 执行source ~/.zshrc 快看有历史记录提示了，按下右方向键即可自动选中 安装incr自动提示插件incr官网incr是一款自动提示插件，功能非常强大，官网演示demo，感受一下 创建incr目录mkdir $ZSH_CUSTOM/plugins/incr 下载incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O $ZSH_CUSTOM/plugins/incr/incr.plugin.zsh Activate the plugin in ~/.zshrc:1vim ~/.zshrc plugins添加incr123456plugins=( git, zsh-syntax-highlighting, zsh-autosuggestions, incr) 执行source ~/.zshrc 修改主题默认主题是robbyrussell我习惯用的主题是ys，接下来我将默认主题修改ys vim ~/.zshrc 找到ZSH_THEME=&quot;robbyrussell&quot;将robbyrussell修改为ys 执行source ~/.zshrc 主题效果图如下： 错误insecure directories, run compaudit for list. 当ssh连接到Linux时 当执行source ~/.zshrc时 会报如下错误提示 123456789101112131415161718192021[oh-my-zsh] Insecure completion-dependent directories detected:drwxrwxr-x 2 admin admin 4096 Aug 13 13:11 /home/admin/.oh-my-zsh/custom/plugins/incrdrwxrwxr-x 7 admin admin 4096 Aug 13 12:56 /home/admin/.oh-my-zsh/custom/plugins/zsh-autosuggestionsdrwxrwxr-x 7 admin admin 4096 Aug 13 12:37 /home/admin/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting[oh-my-zsh] For safety, we will not load completions from these directories until[oh-my-zsh] you fix their permissions and ownership and restart zsh.[oh-my-zsh] See the above list for directories with group or other writability.[oh-my-zsh] To fix your permissions you can do so by disabling[oh-my-zsh] the write permission of &quot;group&quot; and &quot;others&quot; and making sure that the[oh-my-zsh] owner of these directories is either root or your current user.[oh-my-zsh] The following command may help:[oh-my-zsh] compaudit | xargs chmod g-w,o-w[oh-my-zsh] If the above didn't help or you want to skip the verification of[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to[oh-my-zsh] &quot;true&quot; before oh-my-zsh is sourced in your zshrc file.zsh compinit: insecure directories, run compaudit for list.Ignore insecure directories and continue [y] or abort compinit [n]? y% 有两种解决方法 方法一，修改目录权限 使用compaudit命令查看被标记为不安全的文件夹 给不安全的目录添加权限1chmod 755 /home/admin/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting 方法二，跳过不安全目录的验证 在.zshrc文件的第一行添加1ZSH_DISABLE_COMPFIX=true 执行source ~/.zshrc","link":"/p/9dad8f4e/"},{"title":"Mermaid test","text":"测试Mermaid显示效果。 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! graph TB A[Hard edge] -->B(Round edge 虽然截取到的一个美丽的东西大大大大大大大大大大的开开开开开开开啦啦啦啦啦啦啦积极急急急) B --> C{这是一个描述} C -->|是| D[Result one] C -->|否| E[Result two] graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] graph TD A(工业用地效率)-->B1(土地利用强度) A-->B2(土地经济效益) B1-->C1(容积率) B1-->C2(建筑系数) B1-->C3(亩均固定资本投入) B2-->D1(亩均工业产值) B2-->D2(亩均税收) graph TD A[Christmas] -->|Get money| B(Go shopping) B --> C{Let me think} C -->|One| D[Laptop] C -->|Two| E[iPhone] C -->|Three| F[fa:fa-car Car] st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","link":"/p/1acbc8ee/"},{"title":"Icarus 添加 Mermaid 图表支持功能并修改为透明背景样式","text":"classDiagram Animal","link":"/p/7b057616/"},{"title":"Mermaid svg height test","text":"The margin on the chart is very high on the narrow screen.You can repeat the question on this page.see: https://github.com/mermaid-js/mermaid/issues/2160 graph TB a[新切片len > 旧切片cap] --> |是|b(扩容) a --> |否|b1(不扩容) b --> c[预估新容量newcap] c --> d{新切片容量最小值 > 2倍旧容量} d --> |是| e[newcap = 新切片容量最小值] d --> |否| e1{旧切片长度小于1024} e1 --> |是| f[newcap = 2倍旧容量] e1 --> |否| f1[新切片在旧切片容量上每次增长25%直到newcap >= 新切片容量的最小值] e --> g[内存对齐] f --> g f1 --> g g --> h[预估内存占用 = 预估容量 * 元素类型大小] h --> i[匹配到runtime申请的内存规格对应的内存] i --> j[newcap = 匹配到的内存 / 元素类型大小] classDef mainStep fill:#02d7f2,color:#000 class c,g mainStep","link":"/p/8d969531/"},{"title":"乔月入园体检","text":"c411f5515ee312ac71e1581a72fb5b7ee240a39b0c0ba967005f20c03838383d06bd45c0057e66049791dfcd076c302a88aa870fe87b779369516460f806773f82378828df3a9ddb9df437b9f3cb4ab9e069334834f6714fc0f6b6d23401a632369e5dc240e546481a99c93569bd0d08ea81437e5303e8a40312fca1095abeb2ae9bc6035212deebad905878827a8f1d90e82721db95de207d768f489466b9d43d84f1a1b708c6b3cc6a0762e61e57bb248d20eb5b5d901d2e0a1aa7ab2c2cca254db15aaf25caab955c3bb30392b8ce86cc7bcd2ff19e5442964a33259538f17fdd152ba569e23a52edd7244ef4e3387e03cc4e5fa1a685f00fd746bfa39bfeebb13a2b874f6068704d1060c0ee9c4d21d440ceeb766c53195bf65ac926540abf52dc03b398c5dc39d6ecdefbccdc129e49f14abe1f76ab09cc87c598ea41a880e1981cde103da807181548218b38be15da641942926924261cb7b448e5ec38455b9db2747a7a70022b7e86ce09e95a750b620fcae51763178bd375afe0198f7b7176fdbe2e1819ff40e2d4aa677328eae093ed58df9d80ece568240954d194aeec66c819eabd84e67051107b4081376f817d6978334de20d4324cbcd864d3da27b8071202c2d56126786a9196fa0597dd187e2a234927e18c0f8f0a1598603 Hey, password is required here.","link":"/p/6271c8/"},{"title":"二、八、十、十六进制转换（图解篇）","text":"背景（Contexts）之前使用SQL把十进制的整数转换为三十六进制，SQL代码请参考：SQL Server 进制转换函数，其实它是基于二、八、十、十六进制转换的计算公式的，进制之间的转换是很基础的知识，但是我发现网络上没有一篇能把它说的清晰、简单、易懂的文章，所以我才写这篇文章的念头，希望能让你再也不用担心、害怕进制之间的转换了。 下文会分4个部分对这个图进行分解，针对每个部分会以图文的形式进行讲解： （二、八、十六进制） → （十进制）； （十进制） → （二、八、十六进制）； （二进制） ↔ （八、十六进制）； （八进制） ↔ （十六进制）； 进制转换算法（Convert）在数字后面加上不同的字母来表示不同的进位制。B（Binary)表示二进制，O（Octal）表示八进制，D（Decimal）或不加表示十进制，H（Hexadecimal）表示十六进制。例如：(101011)B=(53)O=(43)D=(2B)H （二、八、十六进制） → （十进制） 二进制 → 十进制方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 例：将二进制的(101011)B转换为十进制的步骤如下： 第0位 1 x 2^0 = 1； 第1位 1 x 2^1 = 2； 第2位 0 x 2^2 = 0； 第3位 1 x 2^3 = 8； 第4位 0 x 2^4 = 0； 第5位 1 x 2^5 = 32； 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。 八进制 → 十进制方法：八进制数从低位到高位（即从右往左）计算，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。 例：将八进制的(53)O转换为十进制的步骤如下： 第0位 3 x 8^0 = 3； 第1位 5 x 8^1 = 40； 读数，把结果值相加，3+40=43，即(53)O=(43)D。 十六进制 → 十进制方法：十六进制数从低位到高位（即从右往左）计算，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。 例：将十六进制的(2B)H转换为十进制的步骤如下： 第0位 B x 16^0 = 11； 第1位 2 x 16^1 = 32； 读数，把结果值相加，11+32=43，即(2B)H=(43)D。 （十进制） → （二、八、十六进制） 十进制 → 二进制方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 例：将十进制的(43)D转换为二进制的步骤如下： 将商43除以2，商21余数为1； 将商21除以2，商10余数为1； 将商10除以2，商5余数为0； 将商5除以2，商2余数为1； 将商2除以2，商1余数为0； 将商1除以2，商0余数为1； 读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。 十进制 → 八进制八进制以为对应3位二进制。由于十六进制一位可以对应4位二进制数字，用十六进制来表示二进制较为方便。因此，八进制的应用不如十六进制。有一些程序设计语言提供了使用八进制符号来表示数字的能力，而且还是有一些比较古老的Unix应用在使用八进制。 方法1除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。 例：将十进制的(796)D转换为八进制的步骤如下： 将商796除以8，商99余数为4； 将商99除以8，商12余数为3； 将商12除以8，商1余数为4； 将商1除以8，商0余数为1； 读数，因为最后一位是经过多次除以8才得到的，因此它是最高位，读数字从最后的余数向前读，1434，即(796)D=(1434)O。 方法2使用间接法，先将十进制转换成二进制，然后将二进制又转换成八进制； 十进制 → 十六进制方法1除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。 例：将十进制的(796)D转换为十六进制的步骤如下： 将商796除以16，商49余数为12，对应十六进制的C； 将商49除以16，商3余数为1； 将商3除以16，商0余数为3； 读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。 方法2使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制； （二进制） ↔ （八、十六进制） 二进制 → 八进制方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。 例：将二进制的(11010111.0100111)B转换为八进制的步骤如下： 小数点前111 = 7； 010 = 2； 11补全为011，011 = 3； 小数点后010 = 2； 011 = 3； 1补全为100，100 = 4； 读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。 二进制与八进制编码对应表： 二进制 八进制 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 八进制 → 二进制方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。 例：将八进制的(327)O转换为二进制的步骤如下： 3 = 011； 2 = 010； 7 = 111； 读数，读数从高位到低位，011010111，即(327)O=(11010111)B。 二进制 → 十六进制方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。 例：将二进制的(11010111)B转换为十六进制的步骤如下： 0111 = 7； 1101 = D； 读数，读数从高位到低位，即(11010111)B=(D7)H。 十六进制 → 二进制方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。 例：将十六进制的(D7)H转换为二进制的步骤如下： D = 1101； 7 = 0111； 读数，读数从高位到低位，即(D7)H=(11010111)B。 （八进制） ↔ （十六进制） （Figure14：八进制与十六进制之间的转换） 八进制 → 十六进制方法：将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变。 例：将八进制的(327)O转换为十六进制的步骤如下： 3 = 011； 2 = 010； 7 = 111； 0111 = 7； 1101 = D； 读数，读数从高位到低位，D7，即(327)O=(D7)H。 十六进制 → 八进制方法：将十六进制转换为二进制，然后再将二进制转换为八进制，小数点位置不变。 例：将十六进制的(D7)H转换为八进制的步骤如下： 7 = 0111； D = 1101； 0111 = 7； 010 = 2； 011 = 3； 6.读数，读数从高位到低位，327，即(D7)H=(327)O。 扩展阅读包含小数的进制换算(ABC.8C)H=10x16^2+11x16^1+12x16^0+8x16^-1+12x16^-2 =2560+176+12+0.5+0.046875 =(2748.546875)D 负次幂的计算2^-5=2^(0-5)=2^0/2^5=1/2^5 同底数幂相除，底数不变，指数相减，反过来 我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。 参考文献（References）二进制、八进制、十进制、十六进制之间转换 二进制如何转换成八进制","link":"/p/1090975b/"},{"title":"你可能都不知道 Win10 睡眠和休眠的区别","text":"很多人不知道Windows的休眠功能和睡眠功能的区别，我做了一个表格能更直观的看出睡眠和休眠的区别。 睡眠和休眠的区别 睡眠 休眠 描述 在睡眠模式时，系统会将正在处理的数据保存到内存中，除内存以外的所有设备都停止供电，下次启动就可以快速从内存读取信息，恢复到之前的状态。但是若是内存也断电了，数据就会丢失！也就意味着如果之前的工作没保存的话，都算是都白忙了。 在休眠模式时，内存中的所有数据都会存储到硬盘的特定空间内，一般情况下是在C盘下的一个叫hiberfil.sys的文件，这样一来只要重新按下开机键，就会将硬盘里临时存储的内存数据恢复到内存里，即可恢复到之前的正常工作进度。这种模式下，因为不需要供电，因此不怕休眠后发生供电异常，但是电脑从休眠状态恢复到正常状态的速度较慢，其具体时间取决于内存大小和硬盘速度。 优点 省电。 电脑数据不丢。 缺点 电脑一直处于供电状态，一旦停电，工作状态和数据将丢失。 需要大点的空间转存内存中的数据到硬盘。 适用场景 在睡眠模式下，只要轻轻晃动鼠标或是敲击键盘，即可快速恢复到工作状态中。所以适用于短暂时间离开电脑，回来后随时可以使用电脑的状态。 外出使用电脑时，需要节省电池消耗，又希望可以继续之前的执行，同时随时随地快速开启。 电源菜单不显示休眠如果在按下 Win 键的开始菜单中的电源选项中没有显示休眠菜单，可通过如下步骤打开显示： 右键任务栏电源，点击“电源选项”。 点击“选择电源按钮的功能”。 点击 更改当前不可用的设置，勾选 休眠 即可。","link":"/p/26b9edad/"},{"title":"通过配置 CDN 提高网站的打开速度","text":"本博客有使用了 Font Awesome，因此在国内访问极慢，Font Awesome 的all.css、fa-brands-400.woff2、fa-solid-900.woff2加载有时候需要半分钟到几分钟，甚至有时候加载失败，导致图标也不显示。 那么怎么解决此问题呢？ 使用BootCDN这很容易解决办法是使用 CDN。 那用哪家 CDN 呢？这里我用的是 BootCDN，当然你也可以用 jsdelivr、cdnjs 等。由于时间关系我就不去对比 BootCDN 和其他 CDN 服务哪个更快了。 BootCDN 是 猫云 联合 Bootstrap 中文网 共同支持并维护的前端开源项目免费 CDN 服务，致力于为 Bootstrap、jQuery、React、Vue.js 一样优秀的前端开源项目提供稳定、快速的免费 CDN 加速服务。BootCDN 所收录的开源项目主要同步于 cdnjs 开源项目仓库。 自2013年上线以来已经累计为近百万网站提供了稳定、可靠的免费 CDN 加速服务。 经过 DevTools 测试，果然网站加载速度不慢了，通过下图的测试对比，使用 BootCDN 后，加载时间最慢也只有242ms，比之前快了很多了。 你也可以通过 17CE 或 站长之家 测试网站修改CDN前后的打开速度。 如何修改 Icarus 的 CDN通过源码可以得知 hexo-component-inferno 仅仅为 FontAwesome 提供了 fontawesome 和 loli CDN 提供商。 按照官方文档 Icarus用户指南 - CDN提供商，可以通过以下代码配置 iconcdn 的自定义CDN提供商。 _config.icarus.yml123456789101112# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: google # Name or URL of the fontawesome icon font CDN provider # iconcdn: fontawesome # iconcdn: loli # iconcdn: https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.css iconcdn: https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.3/css/all.css","link":"/p/20d26b34/"},{"title":"用排列组合计算一个城市最多能有多少个车牌号码？","text":"如果你对排列组合比较熟悉，那么此题很容计算。本文将根据两种规则来分别计算一个城市最多能有多个车牌号码。 我们先来回忆下排列组合的公式。 排列 组合 车牌号规则通常车牌号的规则为5位字母或数字组成。 数字为0-9。 字母I和O因为比较像1和0因此不能使用，也就是只能使用24个字母。 而且车牌号最多只能有两个字母。 计算通常规则可用车牌号数量按照规则可将车牌号计算方式分为三类： 全部是数字的车牌共 10^5 = 100,000 个车牌号。这个很好理解吧，它和8位二进制最多能表示 256（2^8）种状态的计算方式是一样的。 当车牌号码只有一个字母时。 按照分步乘法： 只有一个字母的五位车牌号的组合方式有 C(5, 1) = 5 种。 24字母每一个字母对应5个组合，因此有 24^1 * 5 = 120 中组合。 剩下4个数字共有 10^4 个状态。 因此总共 C(5, 1) * 24^1 * 10^4 = 1,200,000 个车牌号。 当车牌号码有两个字母时。 按照分步乘法： 有两个字母的组合方式有 C(5, 2) = 10 种。 两个字母可以从24个字母中选择重复字母，则共有 24^2 种状态，每种状态对应5种组合话，就共有 24^10 * 10 种组合 。 剩下3个数字有 10^3 个状态。 因此总共 C(5, 2) * 24^2 * 10^3 = 5,760,000 个车牌号。 按照分类相加，把这三种分类相加，因此车牌号总是为：100,000 + 1,200,000 + 5,760,000 = 7,060,000 个。 为什么不用车牌号不用4位或6位？4位车牌号更容易记忆，为什么不采用4位呢？ 通过上面的计算可以得知，肯定是因为4位的车牌号太少。那我们计算下4位车牌号能有多少个车牌号？（请你先自己计算下。） 我们还是分3类计算： 车牌号纯数字 10^4 = 10,000 个车牌号。 车牌号只有一个字母 C(4, 1) * 24^1 * 10^3 = 96,000 个车牌号。 车牌号只有两个字母 C(4, 2) * 24^2 * 10^2 = 345,600 个车牌号。 总共有 10,000 + 96,000 + 345,600 = 451,600 个车牌号。 比如岳阳市下的县级市汨罗市人口就有68万，而岳阳市共有四个县和2个县级市。岳阳市如果岳阳市采用4位车牌号，那肯定是远远不够的。即使四位车牌号不限制字母规则，也仅仅共有 34^4 = 1,336,336 个车牌号，而岳阳市常住人口就有505万，133万个车牌号也是不够的。 如果无字母限制规则，那么5位车牌号共有 34^5 = 45,435,424 个车牌号，而中国人口最多城市重庆也只有3048万公民，因此5位车牌号完全够用了。 目前我有看到深圳有采用6位的车牌号码，可能深圳外来人口太多了，而且是一线城市，车自然也多，所以5位车牌号不够用了吧。 参考排列组合超详细讲解","link":"/p/4c0abedb/"},{"title":"长沙买房记录","text":"个人记录，仅供参考。 通过这个网站长沙楼盘可以知道开盘时间，把看上的楼盘开盘时间记录下，然后统一找时间去长沙看房。","link":"/p/708df629/"},{"title":"Provisioning profile &quot;xxx&quot; doesn&#39;t include signng certificate &quot;Apple Development xxx1&quot;","text":"iOS 开发比较烦的就是手动管理证书会出现各种问题，虽然从 Xcode 7 开始就支持自动管理证书，但是对于使用手动管理证书的老项目仍需学会如何解决这类问题。 当出现下图第一个报错：Provisioning profile &quot;xxx&quot; doesn't include signng certificate &quot;Apple Development xxx1&quot;，如何解决呢？ 导致此问题的原因是新的 Certificate 不在 Provisioning Profile 中。 到 Apple Developer 页面 Profiles 中找到指定的 Profile。 Edit 该 Profile，勾选 Certificates 列表中所有的证书。 Download 该 Profile，下载后安装即可解决此问题。 那么第二个报错：No &quot;iOS Distribution&quot; signing certificate matching team ID &quot;H6GCWZCE8G&quot; with a private key was found. 怎么解决？和第一个报错解决方法是一样的，只是在第1步之前需要先点击 Mange Certificates... 创建一个 iOS Distribution 证书。","link":"/p/6669f12a/"},{"title":"使用 Docker 执行一条命令即可部署 Wekan","text":"关于 WekanWekan 是一个完全开源和免费的软件协作看板应用程序，具有 MIT 许可证。 无论您是维护个人待办事项清单，与朋友一起计划假期，还是在团队中为您的下一个革命性想法工作，看板都是一个无与伦比的工具，可以让您的事情井井有条。 它们为您提供项目当前状态的可视化概览，并通过让您专注于少数几个最重要的项目来提高您的工作效率。 由于 Wekan 是一款免费软件，您无需将数据交给我们，可以在您自己的计算机或服务器上安装 Wekan。 事实上，我们鼓励您通过在各种平台上提供一键安装来做到这一点。 本文将介绍如何通过 Docker 执行一条命令来部署 Wekan。 拉取 Wekan 源码shell12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~/Documents/Docker/wekan4 [10:39:07] $ git clone https://github.com/wekan/wekan ../wekan12Cloning into '../wekan12'...remote: Enumerating objects: 51346, done.remote: Counting objects: 100% (1682/1682), done.remote: Compressing objects: 100% (860/860), done.remote: Total 51346 (delta 946), reused 1456 (delta 781), pack-reused 49664Receiving objects: 100% (51346/51346), 36.35 MiB | 11.41 MiB/s, done.Resolving deltas: 100% (38065/38065), done.# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~/Documents/Docker/wekan4 [10:51:26] $ ../wekan12/# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~/Documents/Docker/wekan12 on git:master o [10:51:34] $ lltotal 1536-rw-r--r-- 1 ganzhixiong staff 360593 Aug 17 10:51 CHANGELOG.md-rw-r--r-- 1 ganzhixiong staff 194 Aug 17 10:51 CONTRIBUTING.md-rw-r--r-- 1 ganzhixiong staff 14319 Aug 17 10:51 Dockerfile-rw-r--r-- 1 ganzhixiong staff 2609 Aug 17 10:51 Dockerfile.arm64v8-rw-r--r-- 1 ganzhixiong staff 1086 Aug 17 10:51 LICENSE-rw-r--r-- 1 ganzhixiong staff 8048 Aug 17 10:51 README.md-rw-r--r-- 1 ganzhixiong staff 7001 Aug 17 10:51 SECURITY.md-rw-r--r-- 1 ganzhixiong staff 263 Aug 17 10:51 Stackerfile.yml-rwxr-xr-x 1 ganzhixiong staff 9771 Aug 17 10:51 api.py-rwxr-xr-x 1 ganzhixiong staff 51 Aug 17 10:51 app.env-rw-r--r-- 1 ganzhixiong staff 667 Aug 17 10:51 app.jsondrwxr-xr-x 6 ganzhixiong staff 192 Aug 17 10:51 clientdrwxr-xr-x 8 ganzhixiong staff 256 Aug 17 10:51 config-rw-r--r-- 1 ganzhixiong staff 33700 Aug 17 10:51 docker-compose.yml-rwxr-xr-x 1 ganzhixiong staff 133 Aug 17 10:51 find-replace.sh-rwxr-xr-x 1 ganzhixiong staff 567 Aug 17 10:51 find.shdrwxr-xr-x 3 ganzhixiong staff 96 Aug 17 10:51 fix-download-unicodedrwxr-xr-x 3 ganzhixiong staff 96 Aug 17 10:51 helmdrwxr-xr-x 68 ganzhixiong staff 2176 Aug 17 10:51 i18ndrwxr-xr-x 10 ganzhixiong staff 320 Aug 17 10:51 metadrwxr-xr-x 43 ganzhixiong staff 1376 Aug 17 10:51 modelsdrwxr-xr-x 4 ganzhixiong staff 128 Aug 17 10:51 nginxdrwxr-xr-x 4 ganzhixiong staff 128 Aug 17 10:51 openapidrwxr-xr-x 4 ganzhixiong staff 128 Aug 17 10:51 openshift-rw-r--r-- 1 ganzhixiong staff 125 Aug 17 10:51 owasp-zap-scan.yml-rw-r--r-- 1 ganzhixiong staff 171775 Aug 17 10:51 package-lock.json-rw-r--r-- 1 ganzhixiong staff 1318 Aug 17 10:51 package.jsondrwxr-xr-x 31 ganzhixiong staff 992 Aug 17 10:51 packagesdrwxr-xr-x 32 ganzhixiong staff 1024 Aug 17 10:51 public-rw-r--r-- 1 ganzhixiong staff 2808 Aug 17 10:51 rebuild-wekan.bat-rwxr-xr-x 1 ganzhixiong staff 4727 Aug 17 10:51 rebuild-wekan.shdrwxr-xr-x 45 ganzhixiong staff 1440 Aug 17 10:51 releases-rw-r--r-- 1 ganzhixiong staff 8902 Aug 17 10:51 sandstorm-pkgdef.capnp-rw-r--r-- 1 ganzhixiong staff 17091 Aug 17 10:51 sandstorm.js-rw-r--r-- 1 ganzhixiong staff 301 Aug 17 10:51 scalingo.jsondrwxr-xr-x 19 ganzhixiong staff 608 Aug 17 10:51 server-rw-r--r-- 1 ganzhixiong staff 2 Aug 17 10:51 settings.jsondrwxr-xr-x 4 ganzhixiong staff 128 Aug 17 10:51 snapdrwxr-xr-x 4 ganzhixiong staff 128 Aug 17 10:51 snap-src-rw-r--r-- 1 ganzhixiong staff 6446 Aug 17 10:51 snapcraft.yamldrwxr-xr-x 3 ganzhixiong staff 96 Aug 17 10:51 stacksmith-rw-r--r-- 1 ganzhixiong staff 17059 Aug 17 10:51 start-wekan.bat-rwxr-xr-x 1 ganzhixiong staff 23239 Aug 17 10:51 start-wekan.sh-rwxr-xr-x 1 ganzhixiong staff 191 Aug 17 10:51 status-wekan.sh-rwxr-xr-x 1 ganzhixiong staff 35 Aug 17 10:51 stop-wekan.sh-rw-r--r-- 1 ganzhixiong staff 708 Aug 17 10:51 support-at-wekan.team_pgp-publickey.asc-rwxr-xr-x 1 ganzhixiong staff 2459 Aug 17 10:51 test-wekan.shdrwxr-xr-x 3 ganzhixiong staff 96 Aug 17 10:51 testsdrwxr-xr-x 6 ganzhixiong staff 192 Aug 17 10:51 torodb-postgresqldrwxr-xr-x 3 ganzhixiong staff 96 Aug 17 10:51 trello-rw-r--r-- 1 ganzhixiong staff 244 Aug 17 10:51 wekan-dockerfile-manifest.yaml 配置 docker-compose.yml 文件修改 wekandb 容器名称docker-compose.yml12345678910111213141516171819202122232425262728services: wekandb: #------------------------------------------------------------------------------------- # ==== MONGODB AND METEOR VERSION ==== # a) mongodb latest, like 3.2 - 4.4 or newer https://hub.docker.com/_/mongo?tab=description # 2020-12-03: # - Mongo image copied from Docker Hub mongo:4.4.2-bionic to Quay # to avoid Docker Hub rate limits. # Quay image does work: # image: quay.io/wekan/mongo:4.4.2-bionic # Docker Hub MongoDB image does work: image: mongo:4.4 #-------------------------------------------------------------------------------------- container_name: wekan-db+ container_name: wekan-db12 restart: always # command: mongod --oplogSize 128 # Syslog: mongod --syslog --oplogSize 128 --quiet # Disable MongoDB logs: command: mongod --logpath /dev/null --oplogSize 128 --quiet networks: - wekan-tier expose: - 27017 volumes: - wekan-db:/data/db - wekan-db-dump:/dump 修改 wekan 容器的名称、端口号、地址docker-compose.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 wekan: #------------------------------------------------------------------------------------- # ==== MONGODB AND METEOR VERSION ====+ # 关于 quay.io/wekan/wekan 和 wekanteam/wekan 的区别，请看 https://github.com/wekan/wekan/issues/1914 # a) Quay automatic builds do work work, https://quay.io/wekan/wekan # image: quay.io/wekan/wekan # b) Using specific version tag: # image: quay.io/wekan/wekan:v4.52 # c) Docker Hub builds do work https://hub.docker.com/r/wekanteam/wekan image: wekanteam/wekan #-------------------------------------------------------------------------------------- container_name: wekan-app+ container_name: wekan-app12 restart: always networks: - wekan-tier #------------------------------------------------------------------------------------- # ==== BUILD wekan-app DOCKER CONTAINER FROM SOURCE, if you uncomment these ==== # ==== and use commands: docker-compose up -d --build #build: # context: . # dockerfile: Dockerfile #------------------------------------------------------------------------------------- ports: # Docker outsideport:insideport. Do not add anything extra here. # For example, if you want to have wekan on port 3001, # use 3001:8080 . Do not add any extra address etc here, that way it does not work. # remove port mapping if you use nginx reverse proxy, port 8080 is already exposed to wekan-tier network- - 80:8080+ # hostPort:containerPort。将容器内部端口8080映射到外部宿主机端口8082。+ - 8082:8080 environment: - MONGO_URL=mongodb://wekandb:27017/wekan #--------------------------------------------------------------- # ==== ROOT_URL SETTING ==== # ROOT_URL 是必填的，不然wekan都打开不 # Change ROOT_URL to your real Wekan URL, for example: # If you have Caddy/Nginx/Apache providing SSL # - https://example.com # - https://boards.example.com # This can be problematic with avatars https://github.com/wekan/wekan/issues/1776 # - https://example.com/wekan # If without https, can be only wekan node, no need for Caddy/Nginx/Apache if you don't need them # - http://example.com # - http://boards.example.com # - http://192.168.1.100 &lt;=== using at local LAN #- ROOT_URL=http://localhost # &lt;=== using only at same laptop/desktop where Wekan is installed+ # 用下面三种方式都可以在局域网中访问到+ - ROOT_URL=http://192.168.0.4+ # - ROOT_URL=http://127.0.0.1+ # - ROOT_URL=http://0.0.0.0 一条命令部署shell1234567# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~/Documents/Docker/wekan12 on git:master o [11:08:55] $ docker-compose up -d Creating network &quot;wekan12_wekan-tier&quot; with driver &quot;bridge&quot;Creating volume &quot;wekan12_wekan-db&quot; with local driverCreating volume &quot;wekan12_wekan-db-dump&quot; with local driverCreating wekan-db12 ... doneCreating wekan-app12 ... done shell12345# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~/Documents/Docker/wekan12 on git:master x [11:12:29] $ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESef8650e187f4 quay.io/wekan/wekan &quot;node /build/main.js&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8082-&gt;8080/tcp, :::8082-&gt;8080/tcp wekan-app126f91e0465e86 mongo:4.4 &quot;docker-entrypoint.s…&quot; 5 seconds ago Up 3 seconds 27017/tcp wekan-db12 浏览器中打开点击 http://localhost:8082 在浏览器中打开 Wekan。 第一个注册用户将是管理员，然后是普通用户。如果您也需要其他管理员，您可以在管理面板中将他们的权限更改为管理员。 如果注册的时候提示“内部服务器错误”，这是正常的，是因为你没有配置电子邮件。具体请看 https://github.com/wekan/wekan/wiki/Adding-users 。","link":"/p/464eea27/"},{"title":"Apache httpd 反向代理非80端口和二级域名配置","text":"当服务器80端口被占用时，我们回使用非80端口。比如 使用 Docker 执行一条命令即可部署 Wekan 文中 Wekan使用是8082端口，并且在浏览器中要访问 Wekan 输入的网址为 http://ip:port，这样就存在下面问题： 通过浏览器访问的网址为 IP 加端口号，而不是域名。 现在都是域名，谁会去记IP。 服务器对外暴露的端口越多越不安全。 要解决这些问题，就得通过 Web 服务器的反向代理来实现。本文将介绍下如何使用 Apache httpd Web 服务器实现发现代理非80端口和二级域名配置。 步骤 添加域名解析，我这里使用的是阿里云，我把wekan添加到一个二级域名wekan.xxx.com。 先查看 Wekan 使用的端口，确认为 docker 中运行的 Wekan 使用8080端口，映射到本机的也是8080端。 测试网站可以访问，执行如下命令进行访问测试： shell1curl http://127.0.0.1:8080 配置httpd反向代理，编辑httpd.conf: shell1sudo vim /etc/httpd/conf/httpd.conf 任选如下一种配置方式，添加到 httpd.conf。 方式一 httpd.conf12345&lt;VirtualHost *:80&gt; ServerName wekan.xxx.com ProxyPass / http://localhost:8080/ ProxyPassReverse / http://localhost:8080/&lt;/VirtualHost&gt; 方式二 httpd.conf12345678910111213&lt;VirtualHost *:80&gt;ServerName wekan.xxx.comServerAlias wekan.xxx.comProxyRequests off&lt;Proxy *&gt;Order deny,allowAllow from all&lt;/Proxy&gt;&lt;Location /&gt;ProxyPass http://localhost:8080/ProxyPassReverse http://localhost:8080/&lt;/Location&gt;&lt;/VirtualHost&gt; 重启httpd服务 shell1$ sudo systemctl restart httpd.service 打开浏览器访问wekan.xxx.com","link":"/p/711a2f0d/"},{"title":"使用crontab 和 Certbot 对免费的 Let’s Encrypt 证书自动续期","text":"Let’s Encrypt 颁发的证书的有效期只有90天，每次快过期的时候就需要手动更新 SSL 证书。如果项目只有你一个人维护，刚好你休假了，休假前你也忘记手动更新证书了，那么就没法了，想想在外面玩，遇到这事还得找个网吧紧急处理的心情。😞😞😞 如果你有看过我写的 Linux定时任务crontab，我相信你已经想到了使用crontab来创建一个任务定时自动更新证书。没错，这篇文章就是要讲这个。 什么是 Let’s Encrypt ？SSL 证书一般均需要付费且价格不算便宜（一般最便宜的一档 SSL 一年的费用为 500 元左右），免费的证书较少且申请也较为麻烦。 Let’s Encrypt 是由 Mozilla 联盟思科推出的开源免费证书，旨在帮助全球网站取得 HTTPS 证书进而加密用户与网站之间的流量传输，目前已经得到了所有主流浏览器的支持。这套证书的安装也非常简单。 Let’s Encrypt 是 一个叫 ISRG （ Internet Security Research Group ，互联网安全研究小组）的组织推出的免费安全证书计划。参与这个计划的组织和公司可以说是互联网顶顶重要的先驱，除了前文提到的三个牛气哄哄的发起单位外，后来又有思科（全球网络设备制造商执牛耳者）、 Akamai 加入，甚至连 Linux 基金会也加入了合作，这些大牌组织的加入保证了这个项目的可信度和可持续性。 什么是 Certbot ？尽管项目本身以及有该项目签发的证书很可信，但一开始 Let’s Encrypt 的安全证书配置起来比较麻烦，需要手动获取及部署。存在一定的门槛，没有一些技术底子可能比较难搞定。然后有一些网友就自己做了一些脚本来优化和简化部署过程。其中有一个网友 xdtianyu 做了一个可以快速获取及更新证书的 letsencrypt.sh 脚本被广泛使用。 首先要感谢 xdtianyu 同学的努力付出。我之前用的也是这个脚本，不知道是不是姿势不对，虽然顺利地按照流程装上了，但用 SSLlabs 检测我配的网站还是不太安全，在很多浏览器上都被标注为“不安全”。当时因为忙也没有太多时间折腾和细究。 后来看到 ISRG 的发起者 EFF （电子前哨基金会）为 Let’s Encrypt 项目发布了一个官方的客户端 Certbot ，利用它可以完全自动化的获取、部署和更新安全证书。这真是非常容易、方便呀，所以我们就可以直接使用官方客户端，不需要再使用第三方的工具了。虽然第三方工具也可以使用，但是官方工具更权威，风险也更小，而且遇到问题也更容易解决，毕竟有官方的支持。何况 Certbot 确实非常方便，也比所有的第三方工具都更方便，何乐而不用呢? Certbot 如何安装及安装后如何获取 HTTPS 证书还是那句话，直接看官方文档，网上很多第三方的文章其实都是炒来炒去，可能不对或已过时。因此我不会在我的博客里面重复写这些。 官方文档 真的写的很详细了，选择你的使用的 web server 和操作系统就看打开对应的安装使用说明文档。 HTTPS证书自动续期步骤1. 查看证书信息123456789101112131415161718192021222324252627$ sudo certbot certificates[sudo] password for admin: Saving debug log to /var/log/letsencrypt/letsencrypt.log- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Found the following certs: Certificate Name: api.xxx.com Serial Number: 347c6f791cc3703d6dd475aedd6201253b8 Key Type: RSA Domains: api.xxx.com Expiry Date: 2021-08-03 01:22:38+00:00 (VALID: 82 days) Certificate Path: /etc/letsencrypt/live/api.xxx.com/fullchain.pem Private Key Path: /etc/letsencrypt/live/api.xxx.com/privkey.pem Certificate Name: cnapi.xxx.com Serial Number: 39628b88c7639e157e0d4c266bad5ec9457 Key Type: RSA Domains: cnapi.xxx.com Expiry Date: 2019-05-02 11:46:07+00:00 (INVALID: EXPIRED) Certificate Path: /etc/letsencrypt/live/cnapi.xxx.com/fullchain.pem Private Key Path: /etc/letsencrypt/live/cnapi.xxx.com/privkey.pem Certificate Name: repo.xxx.com Serial Number: 3c0afafad7e521dcaaf89c3aa9f51b61724 Key Type: RSA Domains: repo.xxx.com Expiry Date: 2017-12-19 06:59:00+00:00 (INVALID: EXPIRED) Certificate Path: /etc/letsencrypt/live/repo.xxx.com/fullchain.pem Private Key Path: /etc/letsencrypt/live/repo.xxx.com/privkey.pem- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 通过证书信息，我们知道证书过期时间为2021-08-03 01:22:38。 2. 使用强制更新证书命令为什么要强制更新呢？ 因为 crontab 是不能直接按天数定时执行任务的。 而且当证书还有效时，并不会更新证书。当证书离过期时间很接近时，执行更新才会真正更新SSL证书。 所以为了确保证书能真正被更新，故采用强制更证书的方式更为妥当。 当然如果你要想按天数定时执行，也是可以间接实现的。当然这不是本文的重点，感兴趣的话请参考 crontab中如何实现每隔多少天执行一次脚本。 certbot 强制更新证书只用加上 --force-renewal 参数， 执行命令 certbot renew --force-renewal即可。如果是想更新指定的证书使用参数--cert-name 。如： 1sudo certbot renew --cert-name api.xxx.com --force-renewal 3. 编写更新证书脚本对于要执行的命令比较长时，写成脚本更加方便。 1sudo vim certbot-renew.sh 脚本内容如下： 123456789101112#!/bin/bash# author gan#service tomcat restartecho &quot;==================Certbot Renew=====================&quot;echo &quot;==================`date`============================&quot;# 更新TLS证书/usr/bin/certbot renew --cert-name api.kingtingtech.com --force-renewal# 重启Web服务器systemctl restart httpdecho &quot;==================End===============================&quot; 4. 创建crontab任务 进入编辑crontab任务列表1sudo crontab -e 添加定时执行更新证书脚本的任务 10 3 1 * * /ktt/crons/certbot-renew.sh &amp;&gt;&gt; /ktt/crons/certbot-renew.log 0 3 1 * * 指每个月1号3点0分执行任务 &amp;&gt;&gt;&amp; 指将标准输出和标准错误输出都重定向到certbot-renew.log文件；&gt; 指覆盖写入到文件；&gt;&gt; 指追加写入到文件。 bash手册： 123456789standard error: &amp;&gt;word and &gt;&amp;wordOf the two forms, the first is preferred. This is semanticallyequiva- lent to &gt;word 2&gt;&amp;1 保存。","link":"/p/95b00866/"},{"title":"MySQL 如何监听执行的 SQL 语句？","text":"通过监听数据库的 SQL 语句： 可以了解业务逻辑。 可以知道哪些表查询很频繁，如果该表不是经常变化，可以做cache，提高客户端响应速度。 对主备延迟要求不高的表，读可以放到备库。 等待…… 在 SQL Server 中想要监听执行了哪些 SQL 语句，可以通过自带的可视化界面工具 SQL Server Profiler，由于是可视化的，所以使用起来也是非常的简单。 那么 MySQL 怎么监听执行的 SQL 语句呢？一般数据库开启了 SQL 监听是会影响数据性能的，那么开启后又如何关闭呢？ show log 和 general log slow log 可以定位一些有性能问题的 SQL。 general log 会记录所有的 SQL，非常消耗资源，为了性能，因此默认是关闭的。 MySQL 5.0 版本，如果要开启 slow log、general log，需要重启。MySQL 5.1.6 版开始，general query log 和 slow query log 开始支持写到文件或者数据库表两种方式，并且日志的开启，输出方式的修改，都可以在Global级别动态修改。 1234567MariaDB [(none)]&gt; select version();+----------------+| version() |+----------------+| 5.5.68-MariaDB |+----------------+1 row in set (0.00 sec) 永久监听方法（不推荐）通过编辑 my.cnf 文件，设置 general_log 为1，并且配置 general_log_file 的 log 文件。然后重启 MySQL，此操作永久生效。 123[root@git-server ~]# grep general_log /etc/my.cnfgeneral_log = 1general_log_file = /tmp/general.log 当然这种方式是不允许在生产上采用的。因为要重启MySQL，会中断MySQL的业务。同时日志文件会记录所有的关于 MySQL 的 DDL 和 DML 语句，非常消耗资源，一般都是在协助排除 MySQL 故障时，临时短暂的开启几分钟。事后都要关闭的。 临时监听方法（推荐）1234567891011121314151617181920212223242526# Step 1：设置日志文件位置。mysql&gt; set global general_log_file='/tmp/general_log';Query OK, 0 rows affected (0.00 sec)# Step 2：开启日志监听。mysql&gt; set global general_log=on;Query OK, 0 rows affected (0.02 sec)# Step 3：查看配置是否生效。mysql&gt; show global variables like '%general%';+------------------+------------------+| Variable_name | Value |+------------------+------------------+| general_log | ON || general_log_file | /tmp/general_log |+------------------+------------------+2 rows in set (0.00 sec)mysql&gt; # Step 4：通过 tail 命令查看监听到的 SQL 语句。[root@git-server ~]# tailf /tmp/general_log180717 22:55:51 2 Query show databases180717 22:56:04 2 Query SELECT DATABASE() 2 Init DB test180717 22:56:14 2 Query select * from student3 注意在第四步的时候，执行 tail 命令可能提示找不到 tmp 目录下面的 general_log 文件，执行 sudo find /tmp/ -name general_log 这条命令查找下即可。 最后一定要记住关闭监听。 123456789101112131415161718192021MariaDB [(none)]&gt; show global variables like '%general%';+------------------+----------+| Variable_name | Value |+------------------+----------+| general_log | ON || general_log_file | Main.log |+------------------+----------+2 rows in set (0.01 sec)# Step 5：关闭日志监听。MariaDB [(none)]&gt; set global general_log=off;Query OK, 0 rows affected (0.01 sec)MariaDB [(none)]&gt; show global variables like '%general%';+------------------+----------+| Variable_name | Value |+------------------+----------+| general_log | OFF || general_log_file | Main.log |+------------------+----------+2 rows in set (0.00 sec)","link":"/p/db917aa9/"},{"title":"乔月宝宝感冒","text":"c411f5515ee312ac71e1581a72fb5b7ee240a39b0c0ba967005f20c03838383da258402ef7e8773fedf703ceef001447d913663a3e077363b30a61722d89ca33ea7077877418131f778faebebe431045b2f3f3f692b5043c2a1060331d71443f7a8e63fcdfc432f2f7b0e3fc42eba580acf9b13714959cf7a5f7d13cdb958cfa3ba86e1346236bd87660264e969a833dc20eb3cf14ed3c16aa47efdb4fc252fe9932c0aece519970751835bbda8b5023927c9d1fe0e81a55d632167b0b93357b78b58d36b839c3c4b416c4e1f55065dc2126bca5e0b63aa013a5777c55132d04b376659ebd3273c001d02b225fde0fe8194b40cf3f98520643e1d8e3aaf37cb1069436bd785c41344f4165b0ae766bb5b039a7c7a217714f3afec95ca528bb4539ae9d9113b8d59734aa4481cd05bcbe06e599e8fcfddb4c3d599ad3d34a0dc3c75ba0a2c83473b4ca1c4d77ebe098c64cab56ed7342c30c453a628a9a2573f9af01179b6b8ea7282da7a7c3105526d04994f966add022ae95f6065f0cadaa61a4f5d4e54a24a5a96d01ab866d840b995ecabb52b2dbfd1abc0ff928084702e69021e69bc1d028849017f464bd1181ba1537b211976d9ed50ced9efb09ec10311d77ffc5fee329247c8235650128fd6b83c4354bfbba8ed4760ffc007b42e8e23ffb21af618736dff197f0c0869d696564755514b0e0b7b5299f3874168c8113a9df07dcc35814b02b54b6a3b8eabc70966abdf639a9853c3e3a091be3adead0a529777b842c4e7a780bc584965a69133c534bc928c2166e8206b5dbccfe959efbcd7c2f378368e2bcf6641af53a08fc1378c07a26e70bb41e664a21efa290becc1885afaa08ce486ccc4d44c585689147bdafdcbf3e2f2d9398863d3d44aa160be2f4f1a9183b0385dc32d6464b215d66a30c9bc2b2277d9fc3d88c1777231b5c46d46c1a19df4b6ff8a6354f9b006e226843f6e8964bf6097cd3e85326255481af85210d416cc8231b07acf31dad2915d854992063d50a3bf876b794903810675d040f6f63eb7e41a01114e7d88c72234a976e32456344e34290c078245a74335e5c57f3aad1df4b0fee8a9cbf16590bae18d162f01762c972c62c7e49ec59040f2c8487bedddca663ba9b5a5fa8e3bd3a47e479713885c0a4624778d94526388096c3a7b97f169c0e61e807be67f27d147765c835dce68d36d5bb61aabcb74a7367e4f11e45d1790f121216067b43acfb567ddff7a1d539e70ba1abbe6a5d4d88c3dcd68faf3829b0a36a29eea8f11084d2389dd9c4c699c0fd15951155e787f2bf79e4b5c834a5f24ed5ca381cf0e7e799122b14bb6efd77ad6a1510f81460cbed4b36bc2b50740a82b932cd41c37287e7ed3725f898c8dfd8445e907875d5fa3864d822ab511410e15f7c842c32439b26f36c9b5043ecca3f45f6b3efe189f61f47139daa41505209871917ace0b47922353be6144ed6016b3a28e3ba2f19b106de6df3f67cfdad9c9a0927357ef5a7cdc7ce830b9b667bcdaf3814c68fd043e3baa17c9d01e54515694ac5f0aca639759c5f42588fa05822efaa25b6a398c5e912a90b94df38e4cf40970e35c254dbbaa93f9e548c013dd2b90a296b4ef1e2a1265136123524f07b5d460bceb0f21eee51da26fb3704c777d9e9b0a784fb53ee37f48bab7cf3a8d07ad50325a822630fdb0905db0c7544a2ff0cd2e708c4df8505310f5473d2b4f935e49cf34b361975bc9667e8db2d83c49e3e65c2adedc205877650c3d59570c1ae0979211de5a7645b209ae2a307080ffef3983bc025e13392875a7499e4f7798a8faa8fcd5dc493b3d1799f962fbecea9868f96dd3c13e8f01c33bc838167215fbe9bdbb5c8d49119a6efb99c94ac338807d7cc22fffdf7184a29b504c4693fd93befa0839759c298e5be91e88c6ad077f306d2d2164f290bdfe82bedd08bba44ffa4a16c4c8d50a86f247f8290769ec3ac213221d4aef6d608a17106e2c68710c74cc9208ed40c6d4924c42b9765998ef0032bfb4b551fa5609f596996be69e179e8ec07b04272e94dc52ebe537972bccca7f580df17acaa91087db70fc6bf420d4003b9d91cbfa6d2f85bb0a069e7f311d5d1ee593465b3695e069cfba78d0038e127814ba9956cd32528a8dd38eaffd0004e57cf8a8f0c062a827009416cc9c0e10ba40825e3166597f9969424cf9e87df6914a3e03fe97749eb68053a03657d63889d8637226a9f3a0ccac6cca0dfffb20dfb7ca83d00db57339f7b1f5bcbfcb6b16b8b6cfd6fdc852207cc8d7190b099c1451e595910583fd7632ec6ba388c7a1af012ce5f7c841f2953bcda72929134029a7698238fc95f4ca85a6c46495243cfe819e346689362d226a2a1a583029982032603cc05630d1710742418a829fa77048dbbf600c379564a6ff15be7e6b68918c2783571bc1d385c9962c8d8fdd2471a5e2e364d5fd6fdd132d0a30785eaf196fdc61b459065ecf8912c3f503ff04ca6360ebd33fb2dc861e952456c61e6ffebf8b6ddafb87e03fa3f50340ff4a80e1b9552e1b15cf9b9a1615b4b082f9b3655974b3bad110953da4f7587cbce879d128501114ed30b27a4c06ea3172c9d27821afd9c041b90e007d18adc84320b85227691d3538a36a0fe196302399bae3b349a7f6a718e4e66872413a97ca0f564e4910992ad39c4603633334810d478621f66dda86a502cb8a28b3318656646ed7c40e0a5ce1dbbca24a72c6b0c81cc979c35bb750928f894f651dbc2cbef425a450c95bee38637027723ec4a0fbcd40ad07513a8a7c98e1b429a6790002c0b0f825608c1658f8e7dbff29348d4e7705404914cc8ee5e137ad7e557a3677fa99b7419058a29e6a028e475d242ac1567c9cd95f192ce617bc51479cfb7f098077d2a9d87fed3db2cfd7941b81d8ced4a2cc7cd14ee9c3467955208438b348b4b3618d096e033e1bcd8c9defede7dbd2bb5a21d8db42544127e0e81134852057ac7a4ebf55e6879a329105ab1914d79047ecdc7cbb557d7cc84f4af854e6ace46ea70d7b4160960a83151f10f1c3369707ee0050804985241fb4bba908b5ce7e2d37854ffdf69514c0d9b4767e53a6ebee8ed9389c3043ed1b708b27f166f7ebd3f47f983a64e0cca03ac720789008cbcdeeebe1f78c580eda0713bdf7ddb9f0df34cffa53b48ac2b5b652f869cf5996c3566d7861884dd3038a4d2c5ed0f15ad2cb301cf364b90a9e307e4a59f43e3435c6957cf2e08863d043e85586501c6c4f3beee362555b542de82687426b5ed71100a Hey, password is required here.","link":"/p/996986e/"},{"title":"Linux 中你可能一直在错误的使用 kill 进程","text":"我先抛出如下问题： 杀死了父进程后，子进程也会被杀死吗？ 你了解进程组吗？ 请你先思考下。再看结论： graph TB a[kill 父进程] -->b{父进程 ID 和进程组 ID 是否相同?} b -->|是| c[父进程和子进程都会被 kill] b -->|否| d[父进程会被 kill, 但是子进程不一定会被 kill] c --> e[通过 kill 进程组可以 kill 父进程和全部子进程] d --> e classDef mainStep fill:#02d7f2,color:#000 class e mainStep 杀死父进程并不会同时杀死子进程启动进程模拟1234567891011121314151617181920212223242526272829# 启动一个虚拟进程。# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [22:52:49] $ sleep 300 &amp; [1] 19307# 再启动一个虚拟进程。# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [22:54:14] $ sleep 300 &amp;[2] 19317# 查看这两个进程。# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [22:54:15] $ ps j -A | egrep -i 'PGID|sleep' | cut -c 1-200USER PID PPID PGID SESS JOBC STAT TT TIME COMMANDganzhixiong 19307 18589 19307 0 1 SN s010 0:00.00 sleep 300ganzhixiong 19317 18589 19317 0 1 SN s010 0:00.00 sleep 300ganzhixiong 19332 18589 19331 0 3 S+ s010 0:00.00 egrep -i PGID|sleep# 查看这两个进程的父进程。# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [22:54:20] $ ps -fp 18589 UID PID PPID C STIME TTY TIME CMD 501 18589 18585 0 10:43PM ttys010 0:02.52 -zsh# 结束这两个进程对应的父进程。# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [22:56:27] $ sudo kill -9 18589[进程已完成] 用 Node.js 应用演示123456789101112131415161718192021# admin @ Main in ~ [23:24:35] C:1$ ps jf -A | egrep -i 'PGID|homens' PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND24536 26167 26166 24536 pts/0 26166 S+ 1000 0:00 | \\_ grep -E --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox -i PGID|homens 1 18911 18907 16898 ? -1 Sl 0 0:00 node /ktt/NewNS/YS-LoraHomeNS/app.js18911 18927 18907 16898 ? -1 Sl 0 3:58 \\_ /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/app.js18927 18946 18907 16898 ? -1 Sl 0 0:35 | \\_ /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/lib/dispatcher/ThreadLogicDispatcher Main.BJ.KTT/118911 18928 18907 16898 ? -1 Sl 0 0:00 \\_ /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/lib/schedule/Dispatcher/handler Main.BJ.KTT/Master18911 18991 18907 16898 ? -1 Sl 0 0:01 \\_ /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/lib/Weather/index Main.BJ.KTT/Master# admin @ Main in ~ [23:26:50] C:1$ sudo kill -TERM 18911[sudo] password for admin: # 可以看到，结束了父进程，并没有同时结束所有的子进程。并且子进程的父进程的 ID 变成了 1。# admin @ Main in ~ [23:27:02] $ ps jf -A | egrep -i 'PGID|homens' PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND24536 26326 26325 24536 pts/0 26325 S+ 1000 0:00 | \\_ grep -E --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox -i PGID|homens 1 18928 18907 16898 ? -1 Sl 0 0:00 /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/lib/schedule/Dispatcher/handler Main.BJ.KTT/Master 1 18991 18907 16898 ? -1 Sl 0 0:01 /ktt/common/download/node-v6.9.2-linux-x64/bin/node /ktt/NewNS/YS-LoraHomeNS/lib/Weather/index Main.BJ.KTT/Master 通过以上结果，可以得出如下结论：当结束父进程时，并不一定会结束所有的子进程。 进程组进程组用 PGID 表示。进程组是一个或多个进程（通常与一个作业关联）的集合，可以从同一个终端接收信号。 从上面 Node.js 应用，可以得知该进程组 ID 为 18907。下面我再举例说明： 12345# ganzhixiong @ ganzhixiongdeMacBook-Pro in ~ [0:39:49] $ ps j USER PID PPID PGID SESS JOBC STAT TT TIME COMMANDganzhixiong 24846 19638 24846 0 2 SN s010 0:00.00 tail -f /var/log/system.logganzhixiong 24847 19638 24846 0 2 SN s010 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn CRON 可以发现 tail 和 grep 的 PGID 是相同的。 通过结束进程组来结束进程及其全部子进程1kill -SIGTERM -18907 我们用一个负数 -18907 向进程组发送信号。如果我们传递的是一个正数，这个数将被视为进程 ID 用于终止进程。如果我们传递的是一个负数，它被视为 PGID，用于终止整个进程组。 参考 [译] 如何杀死一个进程和它的所有子进程 「Linux」- 如何结束进程？","link":"/p/b77ef582/"},{"title":"remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.","text":"今天从 GitHub 上拉取代码时，报如下错误： shell12remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. 原因从 2021 年 8 月 13 日开始，GitHub 不再支持密码方式的身份验证，要求使用基于令牌的身份验证方式因此如果是使用 HTTPS 的方式访问 GitHub，则会出现此问题。而使用 SSH 的方式，则不会受影响。 解决要解决其实也很简单，直接更换为 SSH 的方式即可，这种方式网上一搜便知，我就不介绍 了。 我要讲的是另一种方式：使用 Personal access tokens。 打开 https://github.com/settings/tokens。 点击 Generate new token，设置有效期和权限，点击 Generate token。 生成后复制并保存 token，以备后续使用。 接着再终端执行如下命令即可： shell1$ git remote set-url origin https://your-token@github.com/username-or-organization/repository-name.git","link":"/p/df0deb80/"},{"title":"如何通过一条命令合并文件夹下文件到一个文件，并且文件之间添加换行符？","text":"在申请软件著作权的时候，需要将代码放到一个 Word 文档中，用于审核。如果面对大量的代码文件，你一个个去拷贝，那你这个程序员就不合格了😱。 如果你 Linux 命令学的好，在终端一条命令就可以完成合并文件的操作。但是也有不少人在使用命令时，卡在了文件之间如何添加换行符这里。 文件之间不添加换行符方法一1find 12/ -type f | xargs cat &gt; no-line-breaks-1.txt 方法二1find 12/ -type f -exec 'cat' {} \\; &gt; no-line-breaks-2.txt 文件之间添加换行符1find 12/ -name '*.*' -exec 'cat' {} \\; -exec echo \\; &gt; line-breaks.txt 不以换行符结尾的文件末尾添加换行符1find 12/ -name '*.*' -exec awk '1' {} + &gt; line-breaks-awk.txt","link":"/p/dd7c2bd6/"},{"title":"为什么我连个 Wi-Fi 都会使用终端来完成？","text":"前段时间使用 SmartConfig 给网关进行一键配网，需要频繁修改 Wi-Fi 密码进行测试。于是在我修改密码后，再用 macOS 的图形界面连同一个 Wi-Fi 的时候，却提示如下图所示，而不是提示密码错误。 我用的 macOS 版本为 Mojave 10.14.6，这或许是 macOS 的一个 bug。 我也找到了两种解决方法： 在钥匙串中删除该 Wi-Fi SSID 存储的密码。 在终端使用 networksetup 命令连接 Wi-Fi（推荐） 方法一，使用 networksetup 命令连接 Wi-Fi（推荐）从Snow Leopard（Mac OS X v10.6.x）或更早版本开始，您可以执行以下操作： 1networksetup -setairportnetwork $INTERFACE $SSID $PASSWORD $INTERFACE 是您的AirPort卡的“ enX”样式标识符（通常是en1，但en0在MacBook Air和en2Mac Pro中使用，并且由于其他原因也会有所不同） 那么如何确定你的电脑使用 en0 还是 en1 还是 en2 呢？ 有两种方法： 你一个个试，如果是 INTERFACE 错误，会提示 enX is not a Wi-Fi interface.。 先通过图形界面连接 Wi-Fi，然后使用 ifconfig 命令查找 Wi-Fi interface。 $SSID 是您的网络名称，例如&quot;Simon's SSID&quot;。如果包含空格，请用引号引起来。 $PASSWORD 是您的WEP，WPA-PSK或WPA2-PSK密码。 使用该命令，连接成功没有输出，失败会输出错误信息。 查看 Wi-Fi 信息如果你想查看当前连接的 Wi-Fi 信息，使用如下命令： 1/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I 如果仅仅想获取连接的 SSID 名称，使用如下命令： 1/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I | grep -w SSID | awk '{print $2}' 或 1/Sy*/L*/Priv*/Apple8*/V*/C*/R*/airport -I | awk '/ SSID:/ {print $2}' 方法二，在钥匙串中删除该 SSID 后再连接如果你不熟悉命令行，可以使用此方法。 打开钥匙串，用你 Wi-Fi 对应的 SSID 搜索，找到后删除。 再通过图形界面连接。","link":"/p/772ecb8b/"},{"title":"为什么我还在用 macOS Mojave ？","text":"为什么会写这样一篇文章，得从今天一个 GitHub 的 Issue 说起： 今天中午收到我之前在 Karabiner-Elements 提的一个 issue （How can I press the shortcut key and use Google to search for the selected content? #2535） 的 回复。打开后一看，这个问题我已经解决了，他遇到了，那我就帮帮他看看。经过一番答复，最终我得知是由于他使用最新的 macOS Big Sur 导致 open 命令不能打开带有中文的链接，除非中文进行 URL 编码。 看来我的稳定升级系统是非常理智的。我现在是一个比较追求稳定的人，包括 macOS 的更新提醒，我是不会随便更新的，每次都会先查查该升级是否存在问题，若有影响我使用的问题，我是不会升级的。别说我守旧啊😱😱😱，我也会用另一台非生产力的 Mac 升级体验最新特性。 其实这篇文章主要是讲下我如何解决 Big Sur 下 open 命令不能打开带有中文的链接的问题。 问题这里我不重复复述，想看我们讨论的详情，请看 （How can I press the shortcut key and use Google to search for the selected content? #2535 。 在 Big Sur 11.3.1 下 open 命令不能打开带有中文的链接，使用如下命令即可复现： 12ganzhixiong@ganzhixiongdeMacBook-Pro-2 ~ % open 'https://www.google.com/search?q=abc123你好'The file /Users/ganzhixiong/https:/www.google.com/search?q=abc123你好 does not exist. 原因在苹果开发者论坛中 BigSur: open command not handling file URI scheme properly 页面最后一个回复找到了原因。 原因就是 URL 中使用了中文字符导致，如果要含有中文，需要对中文进行 URL 编码。我想着应该是 Big Sur 的一个 Bug 吧，我看还是叫 Bug Sur 吧😡😡😡！ 解决通过 URL 编码搜索关键字即可解决。 我没有找到 Shell 编码的方法，但是我找到了 Python URL 编码的方法，由于 macOS 自带 Python，因此该方法可行，该命令如下： 1open &quot;https://www.google.com/search?q=$(python -c &quot;import urllib, sys; print urllib.quote(sys.argv[1])&quot; &quot;abc123你好&quot;)&quot; 当然也有其他方法用于 URL 编码，我找到了三种方法，分别是： 12345678910111213141516171819# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [22:01:30] $ echo $dataabc123你好# 方法一，使用 perl。# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [22:01:34] $ echo $(perl -MURI::Escape -e 'print uri_escape($ARGV[0]);' &quot;$data&quot;) abc123%E4%BD%A0%E5%A5%BD# 方法二，使用 Python3。# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [22:02:38] $ echo $(python3 -c &quot;import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1]))&quot; &quot;$data&quot;) abc123%E4%BD%A0%E5%A5%BD# 方法三，使用 Python。# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [22:03:27] $ echo $(python -c &quot;import urllib, sys; print urllib.quote(sys.argv[1])&quot; &quot;$data&quot;) abc123%E4%BD%A0%E5%A5%BD 其中方法一，使用 perl 的性能最高。 参考 Possible to urlencode a variable in a shell script?","link":"/p/9dd93282/"},{"title":"Linux 命令实用技巧","text":"掌握这些 Linux 命令技巧后，操作 Linux 命令将更快更便捷！目前想到哪些文章编写哪些，因此会持续更新！ cd -cd - 返回上一次所在目录。 123456789# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [16:03:24] $ cd ~# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~ [16:03:30] $ cd - ~/Documents/blog# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [16:03:34] $ zsh 可以省略 cd 命令。 $_创建目录并进入该目录，一般我们会这么写： 12345# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [16:11:05] C:1$ mkdir -p ~/Downloads/aa/1/2/3 # ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog [16:11:20] C:1$ cd ~/Downloads/aa/1/2/3 如果使用 $_ 符号，可以一条命令，且可以省略 cd 后面的长路径 ~/Downloads/aa/1/2/3 ： 123# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Downloads [16:14:52] $ mkdir -p ~/Downloads/aa/1/2/3 &amp;&amp; echo $_/Users/ganzhixiong/Downloads/aa/1/2/3","link":"/p/5c13f1aa/"},{"title":"kernel_task CPU 占用竟高达 382%，Mac 基本卡死","text":"相信很多人使用 Mac 的时候会遇到电脑卡死的问题。而对于我这款： 处理器 2.2 GHz Intel Core i7 内存 32 GB 2400 MHz DDR4 显卡 Radeon Pro 555X 4 GB、Intel UHD Graphics 630 1536 MB 固态硬盘 512 高配 MBP 也会遇到这类问题，当然是很少出现，平时一般都是至少 600 个进程都很流畅）。 像下图某一次 kernel_task CPU 占用竟高达 382%，这能不卡死吗。 如果你也遇到了这样的问题，不妨看看我的经验分享。 安装 iStat Menus安装 iStat Menus 你能更好的监控 Mac，当然它是需要付费购买，当然也有破解版的，这么良心的软件还是购买正版吧！ 它的功能真的很强大，下图为我配置它显示在菜单栏的选项。 我这里配置菜单栏显示 CPU、内存、传感器温度、电池电量，尤其是这个电池电量的显示有时候真的能起到提醒我该给键盘或触控板电池充电了的作用。 kernel_taskkernel_task 顾名思义就是内核任务进程。它的主要功能之一就是帮助管理 CPU 的温度。 因为是系统内核进程，因此是不能关闭的。 “活动监视器”可能会显示一个名为 kernel_task 的进程正在大量占用 CPU 资源，您可能会注意到在此期间风扇的活动量非常大。 kernel_task 的功能之一是减少正在密集使用 CPU 的进程的可用 CPU 资源，从而帮助管理 CPU 温度。换言之，kernel_task 会对导致 CPU 过热的情况做出响应，即使您并未感觉 Mac 很热。它本身不会导致这些情况。等 CPU 温度下降后，kernel_task 会自动减少其活动。 也就是电脑发热会导致 kernel_task CPU 占用上升。因为 kernel_task 需要管理 CPU 的温度。 什么情况下电脑会卡死？要解决电脑卡死的问题，就得知道什么情况下电脑会卡死，然后具体问题具体分析、具体处理。 高 CPU 占用的进程高 CPU 占用的进程会导致 kernel_task 大量占用 CPU 资源。 Chrome比如下图某一次 Chrome CPU 占用高达 87%，此时 kerne_task CPU 占用 382%，关闭 Chrome 后，就能恢复正常。 而导致 Chrome 占用极高可能是页面开的太多、插件装的太多、启用了 Flash等等。当然还有个更好的方法就是打开 Chrome 的 任务管理器 查看哪个页面和插件占用 CPU 高，将其进程结束即可。 向日葵有的软件有 bug，会大量占用 CPU，比如向日癸远程控制软件，该软件每次在远程一段时间后，就会大量占用 CPU，导致 kernel_task 上升，然后电脑变的很卡了。似乎向日葵升级到最新版本后，没有该问题了。 因此每当电脑卡死的时候，请检查 CPU 的占用情况，如果有进程占用 CPU 极高，可以将该进程对应的软件 kill 后再重新打开。 用左侧雷电口接电源自从 Mac 笔记本将接口全部改为雷电接口后，接口传输速度上升了，充电时左右两边接口都可以插电源线，然而由于习惯问题（之前的磁吸充电口在左边），很多用户都是插左边来给 Mac 供电，没想到正是这个习惯导致电脑温度过热、卡死。 如果排除无高 CPU 占用的用户进程，那么请进行如下操作，或许可以使 kernel_task CPU 占用恢复正常。 将插入在 Mac 左侧雷电接口的充电电源线插入到右侧雷电接口。 请不要将所有的线都插在同一侧接口。如连接两台显示器，请左右侧雷电接口各插一个。 详情请参考 How to find cause of high kernel_task cpu usage? 室温、机身温度很高在排除以上问题后，请确认你的环境温度是不是非常，然后在摸下电脑 C、D 面是不是非常烫。如果是，那就需要给电脑降降温。 电脑降温有如下方案可以尝试： 购买半导体散热器，最好是那种智能温控的，不然长时间可能会导致 Mac 里面产生冷凝水。但是网上大多半导体散热器的价格甚至都超过一台空调的价格，所以也非常的不划算，因此不建议。 所以购买半导体散热器真心不如购买一台空调，即舒服了自己，又舒服的电脑。 买个桌面小风扇对着电脑吹，最好买那种插插座的电源线风扇，那种 USB 的小风扇没啥风力的。 买个金属支架，把 Mac 笔记本放上面，金属的可以传导热量，使得散热加快。","link":"/p/3854a126/"},{"title":"解决 macOS 连接多台显示器从睡眠状态唤醒后 App 在显示器之间互换显示位置的问题","text":"大家使用 macOS 连接多台显示器的应该也会遇到这样的问题，之前有同事也遇到过，我教了她一种比快捷的方法，因为她之前可能会通过将 App 用鼠标或触控板一个一个移动到另一个显示器，该方式真的很麻烦。 我教她的方法是通过 系统偏好设置 → 显示器 → 排列 来设置主显示器解决，但是我觉得的该方式依旧毫无技术。因此我一直想找通过命令行的方式来解决此问题，使用命令行将更快且不需要拖动鼠标。但由于工作忙碌忘记研究命令行的方法，然而最近该问题频繁出现。 作为一名极客，我决定要研究出来！通过 Google 搜索一会儿我就找到命令行的解决方法。最后我通过配置一个快捷键 Tab + D 即可快速恢复显示器排列和主屏幕到睡眠之前的状态。 说了这么多也没说两种方法是什么，不啰嗦，下面我就把这两种方法分享给你，希望能对你有所帮助。 macOS 在命令行这块真的可以甩 Windows 好几个十万八千里啊，maoOS 大部分通过界面完成的操作都可以通过命令行来解决，真的太方便、太爽了！ 问题从标题你也能看出是什么问题，但是没有遇到过的可能就看不明白了。因此我用我自己的环境遇到的问题来描述下。 环境： macOS Mojave 10.14.6（Mojave 最后一个版本） MBP 15寸 2018 外接三台 27 寸 4K 显示器 在系统显示器设置中我将显示器排列和菜单栏位置配置如下图所示： 白色菜单栏：把它拖到那台显示器，那台显示器就是主屏幕，主屏幕就是打开 App，App 会显示在此屏幕上。 问题就是偶尔从睡眠状态到唤醒状态，这个菜单栏就跑到另一台显示器了。而且似乎跑了三次，导致 App 在各个显示器之间位置互换了，然后显示器菜单栏配置就变成了下图这样： 解决通过界面操作解决这种方法就是我之前教同事的方法，它操作原理也很简单，就是拖动白色菜单栏到直到它到你想要的显示器且各屏幕上的 App 已互换位置至未唤醒电脑之前。 该方法虽然操作也简单，但是那个白色的菜单栏又短又窄，一不小心就可能会拖到的是显示器排列，因此是个细活。想象一下本来就是鼠标手，还要搞着玩意，那是多烦躁啊！ 通过命令行解决（推荐）作为程序员，肯定是想方设法的如何通过命令行来完成界面操作咯，就像我连个 Wi-Fi 都是通过命令行来完成的（想学习的，可以看我这篇文章：为什么我连个 Wi-Fi 都会使用终端来完成？）。 我利用 Google 英文搜索，一下就在 apple.stackexchange 找到了同样的问题：Change display arrangement in OS X/macOS programmatically。接着找到答案是使用一个叫 displayplacer 的命令行工具。 displayplacerdisplayplacer 是 macOS 命令行实用程序，用于配置多显示器分辨率和排列。本质上是适用于 macOS 的 XRandR。 安装 displayplacer通过 Homebrew 执行如下命令安装： 1brew tap jakehilborn/jakehilborn &amp;&amp; brew install displayplacer 配置快捷键执行命令 在 系统偏好设置–显示器–排列 里面先设置好显示器排列顺序，然后在设置好主屏幕（白色菜单栏所在显示器）。 在终端执行如下命令，获取显示器分辨率和排列配置。 123456789101112131415161718192021$ displayplacer listPersistent screen id: 21BA3905-792F-A0C6-9727-1A79457072E8Contextual screen id: 459130582Type: 27 inch external screenResolution: 1080x1920Hertz: 60Color Depth: 8Scaling:onOrigin: (0,0) - main displayRotation: 90Resolutions for rotation 90: mode 0: res:1080x1920 hz:60 color_depth:4 scaling:on mode 1: res:1080x1920 hz:60 color_depth:8 scaling:on &lt;-- current mode# 省略...Execute the command below to set your screens to the current arrangement:# 将下面的命令保存到脚本文件，出现问题后执行该脚本即可。# 或用 BetterTouchTool 设置一个快捷键来执行该脚本。displayplacer &quot;id:21BA3905-792F-A0C6-9727-1A79457072E8 res:1080x1920 hz:60 color_depth:8 scaling:on origin:(0,0) degree:90&quot; &quot;id:C9176E3A-21C0-EC84-DD67-8F45B5143A83 res:1920x1080 hz:60 color_depth:8 scaling:on origin:(-1920,450) degree:0&quot; &quot;id:1B206EA1-2E09-2D19-C74D-CB3375D33990 res:1080x1920 hz:60 color_depth:8 scaling:on origin:(1080,0) degree:270&quot; 我是通过 BetterTouchTool 配置一个快捷键来执行该命令，由于配置的是 fn + D fn 不是很好按到，所以我又通过 Karabiner-Elements 将 Tab + D 映射为 fn + D，这样按就方便很多了。","link":"/p/a48328cf/"},{"title":"01《Go语言入门》Go语言简介：历史背景、发展现状及语言特性","text":"⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 历史背景为Google内部挑战而设计Go语言最开始的设计是为了解决Google内部面临的一些挑战而诞生的。这些挑战就包括如下： 多核硬件架构 超大规模分布式计算集群 Web模式导致的前所未有的开发规模和更新速度 2007年9开始设计罗伯特·格瑞史莫（Robert Griesemer），罗勃·派克（Rob Pike）及肯·汤普逊（Ken Thompson）于2007年9月开始设计Go。而这三位Go语言的创始人都是IT界的超级大神。 Ken Thompson（肯·汤普逊） Unix之父（他和C语言之父丹尼斯·里奇一起开发了Unix操作系统） C语言创始人（C语言之父和他，在他开发的B语言基础上开发了C语言) 1983年获图灵奖 Rob Pike（罗勃·派克） Unix的早期开发者 UTF-8创始人 Robert Griesemer（罗伯特·格瑞史莫） Google V8、Chubby和HotSpot JVM的主要贡献者。 2009年11月正式推出Go于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。 2016最佳语言在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言”。 语言特性简单 语言 关键字 Go 25个 C 37个 C++ 84个 高效 支持垃圾回收 支持指针直接访问内存生产力 语法简洁 特别的接口类型 编程约束，很多编程语言都支持复合（Compostion）和继承，复合是大于继承的，在设计模式中经常讲到多用复合，少用继承 发展现状云计算语言 Docker Kubernetes 区块链语言 ethereum HYPERLEDGER","link":"/p/dfeea5ca/"},{"title":"02《Go语言入门》编写第一个Go程序Hello, World","text":"安装Go的步骤，以及编写第一个Go程序”Hello, World!”。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 环境安装下载安装包 进入Golang官网 https://golang.org/ 需要科学上网 https://golang.google.cn/无法科学上网的请访问这个 下载安装包 安装macOS安装如果下载的是pkg文件，则直接双击运行安装；如果下载的是tar.gz压缩文件，则按照Linux安装步骤进行安装。 Linux安装 在终端将包解压到/usr/local目录下 1tar -C /usr/local -xzf 压缩包文件名 # 如go1.15.6.linux-amd64.tar.gz 配置环境变量在$HOME/.profile或/etc/profile中（对于系统范围的安装）添加如下脚本 1export PATH=$PATH:/usr/local/go/bin 执行source命令 123source $HOME/.profile# orsource /etc/profile Windows安装直接下载.msi文件，下载后直接安装。默认是安装在C:\\Go目录下，安装包的形式安装应该是不需要再配置环境变量的。 验证打开终端，输入go或go env或go version。如果能识别go命令，则说明安装成功。 编写Hello World 打开终端，新建test.go文件 输入如下代码12345package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello, World!&quot;)} 运行go run test.go","link":"/p/c02a6a8c/"},{"title":"03《Go语言入门》GoPath 和 GoRoot简介","text":"先是简单介绍了上一篇文中写的Hello, World程序的代码，然后抛出程序如何找到fmt包这个问题，而该问题就涉及到GoPath和GoRoot。通过GoPath讲了如何引用GitHub上的包，并分析了在测试过程中执行 go run XXX_test.go 报错的问题。 这是我纯手写的《Go语言入门》，手把手教你入门Go。源码+文章，看了你就会🥴！文章中所有的代码我都放到了github.com/GanZhiXiong/go_learning这个仓库中！看文章时，对照仓库中代码学习效果更佳哦！ Hello World程序的过程是怎样的？通过上一篇文章，我们编写了第一个Go程序，那么这个代码过程又是怎样的呢？这里还是把代码再贴出来： 12345package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello, World!&quot;)} 第一行代码：建立一个名为main的package，这里的package和Java里面的package是类似的。 第二行代码：导入“fmt”这个包，用于调用Println这个函数。 第三行代码：写一个main()函数。 那么问题来了，“fmt”包是怎么找到的呢？这里就需要我们了解GoRoot和GoPath了。 GoPath和GoRootGoPath是Go的工作目录GoRoot是Go的安装目录使用go env命令可以查看GoPath和GoRoot GoRootfmt包正是通过GoRoot下的src目录找到，在src目录下面我们可以看到有内置的包和函数，如fmt、math、strings等。如果我想是用GitHub上的开源包，该怎么使用呢？那就得用到GoPath了 GoPathGoPath目录约定了三个子目录 src：存放源代码。go run、go install等命令会在此路径下执行 pkg：存放编译时生成的中间文件（*.a） bin： 存放编译后生成的可执行文件（执行go install，会在bin目录下生成可执行文件） 引用GitHub上的包我们要引用GitHub上github.com/gomodule/redigo/redis这个包用进行Redis的操作，该怎么引用呢？ 执行go get github.com/gomodule/redigo/redis获取包获取后，会在GoPath的src目录下生成一个/github.com/gomodule/redigo这样的目录（如果从未运行go get命令，GoPath目录是空的） 在项目中引用创建redis_test.go文件将下面代码写入到redis_test.go1234567891011121314package mainimport ( &quot;fmt&quot; &quot;github.com/gomodule/redigo/redis&quot;)func main() { c, err := redis.Dial(&quot;tcp&quot;, &quot;127.0.0.1:6379&quot;) if err != nil { fmt.Println(&quot;Connect to redis error&quot;, err) return } fmt.Println(&quot;redis connect succ&quot;) defer c.Close()} go run: cannot run *_test.go files执行go run redis_test.go竟然报错了，这是你可能会觉得是代码的问题。🥴🥴🥴你错了。这不是错误，它是这样设计的。 go run将检测_test文件并将其视为程序包的测试文件，测试文件将被编译为单独的程序包，然后与主要测试二进制文件链接并运行。 详情见testing system 您不能将程序文件命名为* _test.go，因为这是集成的Go测试系统的一部分要编写一个新的测试套件，请创建一个名称以_test.go结尾的文件，其中包含TestXxx函数，如此处所述。 将文件与要测试的文件放在同一软件包中。 该文件将从常规软件包生成中排除，但在运行“ go test”命令时将包括在内。 有关更多详细信息，请运行“ go help test”和“ go help testflag”。 参考go not running program with name package_test.go 解决：你只需要将redis_test.go文件名中的test前面的下划线去掉或使用其他名称即可解决","link":"/p/86d4b7a7/"},{"title":"04《Go语言入门》Go常用命令介绍","text":"本文主要介绍Go介绍Go常用的命令：run、build、get、install、env、vet。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ Go提供了很多命令，我们可以通过在终端输入go回车，即可看到： go run编译并执行，只能作用于命令源码文件，一般用于开发中快速测试。如go run test.go go build编译代码包或源码文件。 如果带上包名，表示编译指定的代码包 如果带上源码文件，表示编译指定源码文件go get下载第三方代码包并编译安装。它会下载安装到GOPATH环境变量配置的第一个工作区中。 如上文03 | GoPath 和 GoRoot简介介绍了如何下载GitHub上的代码包。 go install 用于编译安装，将编译后的生成的执行文件放到工程的bin目录下，将生成的归档文件（静态链接库）存放到工程的pkg目录下。 使用方式类似于go build。 可以作用于main包和非main包。 可以在某个代码包目录下直接使用，也可以指定代码包使用。 可以替代go get比如使用go get https://github.com/gomodule/redigo可以下载编译安装代码包。其实也可以直接下载zip压缩包，然后将压缩包解压到GoPath的src目录下，形成github.com/gomodule/redigo目录结构，再执行go install github.com/gomodule/redigo/redis，就会在GoPath的pkg目录下生成/darwin_arm64/github.com/gomodule/redigo目录结构，在redigo目录下会生成一个redis.a的文件。 .a文件是编译过程中生成的，每个package都会生成对应的.a文件，Go在编译的时候先判断package的源码是否有改动，如果没有的话，就不再重新编译.a文件，这样可以加快速度。 go env用于打开Go语言的环境变量。 如： GOPATH是工作区目录 GOROOT是Go语言安装目录 GOBIN是通过go install命令生成可执行文件的存放目录（默认是当前工作区的bin目录） GOEXE为生成可执行文件的后缀go vet代码静态检查工具。如go vet test.go","link":"/p/1932c6e1/"},{"title":"05《Go语言入门》使用GoLand创建、运行和调试Hello, World程序及快捷键介绍","text":"Go语言开发用什么IDEGo语言开发能使用的IDE可多了，如GoLand、Eclipse、VSCode、Atom等，甚至有不少Gopher使用Vim。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 但是，我还是建议初学者使用GoLand作为Go语言开发的IDE，理由很简单，其他IDE需要安装Go插件，GoLand开箱即用，且功能更强大。 唯一缺点就是使用GoLand需要付费。虽然网上有需要共享的License或破解方法，但是还是推荐大家使用正版。Jetbrains出品，必属精品！使用Jetbrains公司出品的IDE，让我更加专注于写代码。 参考：Golang有哪些ide？ - 波罗学的回答 - 知乎 使用GoLand创建Hello, World 创建go_learning Project 创建src目录Go语言规定了src目录为源码目录。 创建package在src目录下创建一个名为main的package 创建hello.go 在main目录下面创建hello.go 1234567package main// IDE会自动导入包，所以可以直接使用fmt，而不需要写下面代码import &quot;fmt&quot;func main() { fmt.Println(&quot;Hello, World!&quot;)} Run将光标定位到绿色运行三角形图标所在的行，然后按下option + enter，选择run或debug，如下图所示：一旦运行了一次，go build hello.go就会添加到Run/Debug Configurations，下次运行就可以直接按 Control + R运行了。 Debug为了能够打更多断点进行调试，我添加了打印Start和End，并且打上断点，如下图所示：按下Debug快捷键Control + D即可进行调试。 Run/Debug 快捷键 快捷键 描述 Control + R Run Control + D Debug Comand + F2 Stop Command + R Rerun Comand + F8 Toggle Line Breakpoint（光标所在行添加或删除断点） Comand + Shift + F8 View Breakpoints（编辑所有断点） Comand + Option + R Resume Program（跳转到下一个断点） F8 Step over（逐过程，不进入函数） F7 Step Into（逐语句，进入函数） Shift + F8 Step Out（跳出函数） Shift + F9 Run to Cursor（运行到光标所在行）","link":"/p/f86503f9/"},{"title":"06《Go语言入门》Go程序结构、入口、退出返回值及获取命令函参数","text":"切记：基础知识和设计原理真的很重要。切记：慢工出细活，心急吃不了热豆腐。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ Go程序结构一个基本的Go程序代码由三部分构成： 包 引入依赖 main函数程序入口12345678910111213// 包，表明代码所在的模块（包）package main// 引入代码依赖// IDE会自动导入包，所以可以直接使用fmt，而不需要写下面代码import &quot;fmt&quot; // 程序入口，功能实现func main() { fmt.Println(&quot;Start&quot;) fmt.Println(&quot;Hello, World!&quot;) fmt.Println(&quot;End&quot;)} 程序入口Go程序的入口必须要满足以下两个要求： 必须是main包：package main 比如将main修改为main1，就会提示一个警告⚠️Unused function 'main'，并且go build hello.go Configuration不可用。如下图所示： 必须是main函数：func main() 比如将函数名称修改为其他名称，同样会出现这个上图一样的问题。 需要注意的是：Go文件名不一定是main.go 退出返回值C++或Java通过main函数可以返回值的，例如返回退出的状态。但是Go中的main函数是不支持任何返回值的。编写代码验证如下图所示： os.Exit(code)在Go中main函数返回程序退出状态，**使用os.Exit(code)**，code的范围为0-125。 正常退出code使用0 异常退出code使用非0 获取命令行传参C++和Java的main函数是支持传入参数的，但是Go语言main函数则不支持。但是它可以和Node.js一样通过命令行传入参数在代码中，通过os.Args获取参数数组例如：","link":"/p/74b87465/"},{"title":"07《Go语言入门》测试用例、变量和常量","text":"从这篇文章开始，为了方便测试代码，我将基本上所有示例代码都写成了测试用例，因此需要先学下测试用例怎么编写，这真的很重要，这是任何工程的开始必做的步骤。然后讲解了单个或多个变量和常量的定义，常量的讲解包括枚举、常量表达式、iota常量、比特位常量等。 重要知识点： 全局变量声明后不使用，程序能够编译成功；而局部变量不可以，声明后必须得使用。 变量短声明方式只能在函数内使用，函数外使用会报错 unexpected 常量不管全局还是局部，声明后可以不使用。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 测试用例在开始讲解变量和常量之前，先简单讲下Go测试程序如何编写。在Go中对测试程序作了如下规定： Go文件名以_test结尾，如：my_test.go 测试方法名以Test开头，如：func TestMy(t *testing.T) 例如下图所示命令行中运行请使用go test -v xxx_test.go，不能使用go run xxx_test.go，这个问题在03《Go语言入门》GoPath 和 GoRoot简介也有讲过。 如果闲func TestMy(t *testing.T)输入麻烦，使用GoLand的话，直接输入tes后，按tab即可自动输入。 后面我也会专门写一篇测试用例的文章。 变量注意：全局变量声明后不使用，程序能够编译成功；而局部变量不可以，声明后必须得使用。 定义单个变量 使用var 12var v intvar a int = 1 不使用var和变量类型但是这种短声明方式只能在函数内使用，函数外使用会报错 unexpected 1b := 2 定义多个变量1234var ( c int = 3 d int = 4) 1234var ( c1 int d1 string) 1var e, f = 5, &quot;f&quot; 定义变量的时候如果在声明的时候初始化，推荐省略变量类型，因为编译器会根据初始化值自动推导类型。 示例斐波拉契数列为了熟悉变量的定义，我编写了用Go语言实现斐波拉契数列的代码。 07_var_test.go1234567891011func TestFibList(t *testing.T) { var a = 1 var b = 1 t.Log(a) for i := 0; i &lt; 5; i++ { t.Log(b) tmp := a a = b b = tmp + a }} 交换两个变量的值在Go中交换两个变量可以不需要中间变量，通过a, b = b, a即可实现。 07_var_test.go12345678910111213func TestExchange(t *testing.T) { a := 1 b := 2 t.Log(a, b) tmp := a a = b b = tmp t.Log(a, b) a, b = b, a t.Log(a, b)} 常量常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式： 1const identifier [type] = value 你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = “abc” 隐式类型定义： const b = “abc” 多个相同类型的声明可以简写为： 1const c_name1, c_name2 = value1, value2 注意：常量不管全局还是局部，声明后可以不使用。 枚举常量还可以用作枚举： 12345const ( Unknown = 0 Female = 1 Male = 2) 常量表达式常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： 12345const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(a)) iota常量iota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： 1234567891011const ( a = iota b = iota c = iota)// 或简写为const ( a = iota b c) 比特位常量使用iota可以给连续的比特位常量赋值，如： 12345const ( Readable = 1 &lt;&lt; iota // 0001 可读 Writable // 0010 可写 Executable // 0100 可执行) 07_constant_test.go123456func TestConstant1(t *testing.T) { t.Log(Readable, Writable, Executable) //a := 7 // 7%2=1 3%2=1 1%2=1 111 a := 1 // 1%2=1 1 t.Log(a&amp;Readable == Readable, a&amp;Writable == Writable, a&amp;Executable == Executable)} 考察如果下面这道题的结果你算对了，那你就理解了iota在枚举中的使用。 07_constant_test.go1234567891011121314func TestConstant3(t *testing.T) { const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a, b, c, d, e, f, g, h, i)}","link":"/p/3d71d7bb/"},{"title":"08《Go语言入门》数据类型、类型转换、指针类型","text":"重要知识点： 整形int和uint的位数由操作系统位数决定，如64位操作系统，则int为有符号64位。 uintptr为无符号整型，用于存放一个指针。 不允许隐式类型转换，即使别名和原有类型也不能进行隐式类型转换。 Go有指针，但是不支持指针运算，即不能通过指针自增来访问连续的存储空间，如数组。 string是值类型，其默认的初始化值为空字符串，而不是null。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 基本数据类型Go语言的基本数据类型分别是：布尔型、数字类型、字符串类型。 类型 描述 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 数字类型 整型 int 和浮点型 float32、float64，并且支持复数，其中位的运算采用补码。 字符串 是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的，字节使用 UTF-8 编码标识 Unicode 文本。 这里我重点讲下数字类型，字符串我会在后面写一篇文章专门讲解。 数字类型数字类型分为：整形和浮点型。 整形整形又分为：无符号整形和有符号整形其中int和uint的位数由操作系统位数决定，如64位操作系统，则int为有符号64位 无符号整形 类型 描述 范围 uint 无符号32位或64位整形 uint8 无符号8位整形 0 - 255 byte 类似uint8 uint16 无符号16位整形 0 - 65535 uint32 无符号32位整形 0 - 4294967295 uint64 无符号64位整形 0 - 18446744073709551615 uintptr 无符号整型，用于存放一个指针 有符号整形 类型 描述 范围 int 有符号32位或64位整形 int8 有符号8位整形 -128 - 127 int16 有符号16位整形 -32768 - 32767 int32 有符号32位整形 -2147483648 到 2147483647 rune 类似int32 int64 有符号64位整形 -9223372036854775808 到 9223372036854775807 浮点型 类型 描述 float32 IEEE-754 32位浮点型数 float64 IEEE-754 64位浮点型数 complex32 32 位实数和虚数 complex64 64位实数和虚数 类型转换类型转换分为两种方式：隐式类型转换和显示类型转换（强制类型转换） 有很多程序员可能连显示类型转换和隐式类型转换的概念都还不清楚 隐式类型转换 - 以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。 显式类型转换 - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换可能会造成数据丢失。 例如：C语言中隐式转换的规则为：小字节类型向大字节类型转换如： C123int a = 1; double b = 1.234;b = a; // 隐式转换a = (int)b; // 显示转换 而Go语言类型转换比较特殊，它和一些主流语言有如下两点不同： 不允许隐式类型转换这意味着不同类型的变量之间不能进行运算操作，如int不能加int32 别名和原有类型也不能进行隐式类型转换 可以看过Go是很严格的语言，严格的好处就是能减少代码出错。 示例下面我用代码来演示下Go的类型转： 08_type_test.go12345678910111213141516171819202122232425262728293031func TestImplicit(t *testing.T) { var a = 1 var b = 2 a = b t.Log(a, b) t.Log(&quot;a type:&quot;, reflect.TypeOf(a)) t.Logf(&quot;b type: %T&quot;, b) // 即使int32在int64范围内，还是会报错，因为Go不支持隐式类型转换 var c int32 = 3 var d int64 = 4 // 报错：Cannot use 'c' (type int32) as type int64 //d = c // Invalid operation: c + d (mismatched types int32 and int64) //var and = c + d d = int64(c) t.Log(c, d) t.Log(&quot;c type:&quot;, reflect.TypeOf(c)) t.Logf(&quot;d type: %T&quot;, d) // 别名和原有类型也不能进行隐式类型转换 var e MyInt var f int64 f = d // Cannot use 'd' (type int64) as type MyInt //e = d e = MyInt(d) t.Log(e, f) t.Log(&quot;c type:&quot;, reflect.TypeOf(e)) t.Logf(&quot;d type: %T&quot;, e)} 这里演示了Go获取变量类型的两种方式： reflect.TypeOf() 格式化输出%T 上面代码的结果我就不贴出来了，先自己计算输出结果，然后自行手写后看执行结果。 数据范围 通过math这个package可以获取数据类型的最大值和最小值。 08_type_test.go123456func TestDataRange(t *testing.T) { t.Log(&quot;int8 范围：&quot;, math.MinInt8, math.MaxInt8) t.Log(&quot;int16 范围：&quot;, math.MinInt16, math.MaxInt16) t.Log(&quot;int32 范围：&quot;, math.MinInt32, math.MaxInt32) t.Log(&quot;int64 范围：&quot;, math.MinInt64, math.MaxInt64)} 指针类型C和C++可以对指针直接进行操作；C#可以使用unsafe操作指针；Java严格来说是没有指针的概念，引用类似指针；那么Go呢？ Go有指针，但是不支持指针运算这意味着不能通过指针自增来访问连续的存储空间，如数组 08_type_test.go12345678910func TestPoint(t *testing.T) { a := 1 aPtr := &amp;a // 进行指针运算会报错： // Invalid operation: aPtr + 1 (mismatched types *int and untyped int) // 无效操作:aPtr + 1(不匹配的类型*int和无类型int) //aPtr = aPtr + 1 t.Log(a, aPtr) t.Logf(&quot;%T, %T&quot;, a, aPtr)} string是值类型，其默认的初始化值为空字符串，而不是null","link":"/p/9375a286/"},{"title":"09《Go语言入门》运算符和其他编程语言的区别","text":"重要知识点： 很多人分不清前置自增和后置自增、前置自减和后置自减，而Go为了简单，只支持后置自增（a++）和后置自减（a–）。 Go中数组（Array）为值类型，相同维数且含有相同个数元素的数组才可以比较，每个元素都相同才相等。 位运算符增加按位置零运算符 &amp;^ ，规则：右1为0，右0为O（Original）。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 算术运算符编程语言中常用的运算符为： 1234567+-*/% // 求余++ // 自增-- // 自减 自增又分为前置自增和后置自增；自减又分为前置自减和后置自减。很多人在学习C语言的时候就经常分不清前置和后置的区别。 无前置自增和前置自减而Go为了简单，只支持后置自增（a++）和后置自减（a–） 09_operator_test.go12345678910111213func TestIncrementDecrement(t *testing.T) { a := 1 a++ // '++' unexpected //++a t.Log(a) b := 1 b++ // '--' unexpected //--b t.Log(b)} 比较运算符常用的比较运算符为： 123456==!=&gt;&lt;&gt;=&gt;= Go的比较运算符和其他编程语言是一致的。 数组的比较但是某些类型的比较方式又和其他编程语言不一样，比如用==比较数组。 在Java、JavaScript中数组是引用类型，数组用==比较时，比较的是两个数组的引用。 但是在Go中数组（Array）为值类型。所以在比较数组的时候有如下规则： Go中相同维数且含有相同个数元素的数组才可以比较 Go中数组每个元素都相同才相等 12345678910111213func TestCompareArray(t *testing.T) { a := [...]int{1, 2, 3, 4} //b := [...]int{1, 2, 3, 4, 5} c := [...]int{1, 3, 2, 4} d := [...]int{1, 2, 3, 4} // Invalid operation: a==b (mismatched types [4]int and [5]int) //t.Log(a==b) // false t.Log(a==c) // true t.Log(a==d)} 那么你可能会问，Go中数组是值传递，很多时候我们为了节省内存，就想使用引用传递怎么办？我们可以使用切片来解决，后面我会单独写一篇文章讲解切片。你可以关注下，相信会对你有所帮助。 逻辑运算符常用的逻辑运算符为： 123&amp;&amp;||! 位运算符常用的位运算符为： 12345&amp; // 按位与运算符| // 按位或运算符^ // 按位异或运算符(相同为0，不同为1)&lt;&lt; // 左移运算符&gt;&gt; // 右移运算符 和其他编程语言不同的是，Go增加了按位置零运算符。 按位置零运算符1&amp;^ 该运算符的规则为： 只要右边的操作数位上为1，无论左边的操作数对应的位上为1还是0，结果都是0。（右1为0） 如果右边的操作数位上为0，结果为左边的操作数对应的位上的值。（右0为O（Original）） 如果你知道原理了就不用记。其实原理也很简单。原理就是：go语言中按位取反写法是^， 所以 a&amp;^b 其实是 a&amp;(^b) 利用运算符优先级省略掉括号的写法而已。 12341 &amp;^ 0 // 11 &amp;^ 1 // 00 &amp;^ 1 // 00 &amp;^ 0 // 0 还记得前面有一篇文章07《Go语言入门》测试用例、变量和常量里面讲到比特位常量吗！这里我们可以使用按位置零运算符，快捷的设置文件类型 07_constant_test.go12345678910111213141516171819202122232425262728const ( Readable = 1 &lt;&lt; iota // 0001 可读 Writable // 0010 可写 Executable // 0100 可执行)func TestConstant1(t *testing.T) { t.Log(Readable, Writable, Executable) //a := 7 // 7%2=1 3%2=1 1%2=1 0111 a := 1 // 1%2=1 0001 t.Log(a&amp;Readable == Readable, a&amp;Writable == Writable, a&amp;Executable == Executable) // 下面演示09讲中的按位置零运算符 a = 7 // 0111 t.Log(a&amp;Readable == Readable, a&amp;Writable == Writable, a&amp;Executable == Executable) a = a &amp;^ Readable a = a &amp;^ Writable a = a &amp;^ Executable t.Log(a&amp;Readable == Readable, a&amp;Writable == Writable, a&amp;Executable == Executable) // 按位运算符其实就是运算符优先级省略掉括号的写法而已 b := Readable | Executable t.Log(b&amp;Readable == Readable, b&amp;Writable == Writable, b&amp;Executable == Executable) t.Log(b&amp;^Readable == Executable) t.Log(b&amp;^Executable == Readable) t.Log(b&amp;(^Readable) == Executable) t.Log(b&amp;(^Executable) == Readable)}","link":"/p/ec65d1ef/"},{"title":"10《Go语言入门》循环和条件","text":"重要知识点： Go仅支持循环关键字for，没有while循环关键字。 条件表达式的结果必须为布尔值。 switch条件表达式不仅支持常量和整数，而且和JS一样支持字符串。 switch不需要break来明确退出一个case。 不设定switch后的条件表达式，能实现if else的效果。 不支持三目（元）运算符。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 循环for循环Go仅支持循环关键字for下面为for循环常用的写法，注意Go中for循环是不用写括号的，写了括号则会报错。 1for i := 0; i&lt;5; i++ 当然还有其他写法，如： 10_loop_test.go1234567891011121314151617func TestLoop(t *testing.T) { t.Log(&quot;你可以这样写&quot;) i := 0 for ; i &lt; 5; i++ { t.Log(i) } t.Log(&quot;也可以这写&quot;) for i = 1 ; i &lt; 5; i++ { t.Log(i) } t.Log(&quot;也可以这写&quot;) for i := 0; i &lt; 5; i++ { t.Log(i) }} while循环上面已经说过了Go仅支持循环关键字for，所以也就没有while关键字了，那么while循环怎么写呢？ while条件循环其他编程语言的while条件循环是这么写的： 123while (n &lt; 5) { ... } 其实Go的while条件循环只是用for替代while，然后省略了括号而已。 123for n &lt; 5 { ...} while无限循环其他编程语言的while无限循环是这么写的： 123while (true) { ... } 那么Go的无限循环也只是将while换成了for，然后省略了括号和括号内的代码而已。 123for { ...} 示例10_loop_test.go123456789101112func TestWhileLoop(t *testing.T) { n := 0 for n &lt; 5 { t.Log(n) n++ } for { t.Log(n) n++ }} 条件if条件Go中也有if、else、else if。和其他语言的区别如下： 不用将条件括号起来，如果加了括号，则会提示警告Unwrap parentheses。 10_condition_test.go1234567891011func TestIf(t *testing.T) { n := -1 //var n int if n &lt; 0 { t.Log(n, &quot;为负数&quot;) } else if n == 0 { t.Log(n, &quot;为0&quot;) } else { t.Log(n, &quot;为正数&quot;) }} 条件表达式的结果必须为布尔值。 例如JavaScript的条件表达式的结果不一定要是布尔值，如： 123if(1) { console.log(&quot;1&quot;)} 而Go则会报错，如： 1234// Non-bool '1' (type untyped int) used as conditionif 1 { } switch条件Go的switch和其他编程语言有如下区别： 条件表达式不限制为常量或整数，而且和JS一样支持字符串。 10_condition_test.go12345678910func TestSwitch(t *testing.T) { switch os := runtime.GOOS; os { case &quot;darwin&quot;: t.Log(&quot;macOS&quot;) case &quot;linux&quot;: t.Log(&quot;Linux&quot;) default: t.Logf(&quot;%s&quot;, os) }} 单个case中，可以出现多个结果选项，使用逗号分隔。 10_condition_test.go123456789101112131415161718192021222324252627282930func TestGetGrade(t *testing.T) { /* 定义局部变量 */ var grade string var marks int = 50 switch marks { case 90: grade = &quot;A&quot; case 80: grade = &quot;B&quot; case 50, 60, 70: grade = &quot;C&quot; default: grade = &quot;D&quot; } switch { case grade == &quot;A&quot;: fmt.Printf(&quot;优秀!\\n&quot;) case grade == &quot;B&quot;, grade == &quot;C&quot;: fmt.Printf(&quot;良好\\n&quot;) case grade == &quot;D&quot;: fmt.Printf(&quot;及格\\n&quot;) case grade == &quot;F&quot;: fmt.Printf(&quot;不及格\\n&quot;) default: fmt.Printf(&quot;差\\n&quot;) } fmt.Printf(&quot;你的等级是 %s\\n&quot;, grade)} 不需要break来明确退出一个case 通过上面的代码，我们可以看到Go的switch不需要写break的，像其他的编程语言则不行。比如JavaScript，不加break，则会执行后面的case，直到break为止。 可以不设定switch之后的条件表达式，整个switch结构与多个if…else…的逻辑作用等同，例如： 10_loop_test.go1234567891011func TestSwitchIfElse(t *testing.T) { n := 5 switch { case n &gt;= 0 &amp;&amp; n &lt;= 3: t.Log(&quot;0-3&quot;) case n &gt;= 4 &amp;&amp; n &lt;=6: t.Log(&quot;4-6&quot;) case n &gt;= 7 &amp;&amp; n &lt;= 9: t.Log(&quot;7-9&quot;) }} 条件表达式支持变量赋值即if或switch表达式之前添加一个执行语句，再根据变量值进行判断，这是if和switch的特殊写法。 123if var declaration; condition { ...} 例如： 1234if err := Connect(); err != nil { fmt.Println(err) return} Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。 这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。 再例如： 10_loop_test.go123456789101112func TestIfMultiSec(t *testing.T) { if a := 1 == 1; a { t.Log(&quot;1 == 1&quot;) } // 在后面我们回经常用到变量赋值的条件表达式，下例就是用到了Go的函数多返回值 //if v, err := Fun(); err == nil { // //} else { // //}} 再例如： 12345678910func TestSwitch(t *testing.T) { switch os := runtime.GOOS; os { case &quot;darwin&quot;: t.Log(&quot;macOS&quot;) case &quot;linux&quot;: t.Log(&quot;Linux&quot;) default: t.Logf(&quot;%s&quot;, os) }} 在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。 不支持三目运算符三目（元）运算符广泛存在于其他语言中，比如：python： 1val = trueValue if expr else falseValue javascript： 1const val = expr ? trueValue : falseValue c、c++： 1const char *val = expr ? &quot;trueValue&quot; : &quot;falseValue&quot;; 然而，被广泛支持的三目运算符在golang中却是不存在的！如果我们写出类似下面的代码： 1val := expr ? &quot;trueValue&quot; : &quot;falseValue&quot; 则编译器会报错。 Go的作者认为三元表达式会让让开发者写出复杂且难以理解的表达式，虽然if-else看上去代码量更多，但是也会阅读起来会更加清晰，而在Go作者看来一种编程语言只需要一种条件控制结构，因此抛弃了三元运算符。","link":"/p/204165a4/"},{"title":"Golang语言现状优缺全面分析","text":"⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 本文是根据B站“刘丹冰aceld”的视频做了一个文字描述。具体请看https://www.bilibili.com/video/av200269949/。 Golang的优势 Golang的强项 Golang的成就 Golang的缺点","link":"/p/f76282da/"},{"title":"11《Go语言入门》数组和切片","text":"本文内容较多，请泡个茶，做好准备！ 重要知识点： Go中没有foreach关键字，但是range 关键字可用于for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。 _ 表示占位，用于替代不使用的变量。 数据截取返回的是切片。 切片是一个共享存储结构，是引用类型。 slice的len大于cap时，会出发扩容。slice的cap增长是当len在1024之前是双倍增长的，而1024以后则是先增长25%以后再调整这个值为系统需要的最小值，因此这个值是约等于cap + cap/4。 ⚡️这是我纯手写的《Go语言入门》，源码+文章，手把手教你入门Go。看了你就会！⚡️文章中所有的代码我都放到了 github.com/GanZhiXiong/go_learning 这个仓库中！⚡️看文章时，对照仓库中代码学习效果更佳哦！ 数组数组的声明 声明指定长度数组，并初始化为默认0值。 12var a [3]inta[0] = 1 声明指定长度数组，同时初始化 1234// 一维数组b := [3]int{1, 2, 3}// 二维数组c := [2][2]int{{1, 2}, {3, 4}} 声明初始化数组时不写长度 1a := [...]int{1, 2, 3, 4, 5} 遍历数组上一篇我们学习知道了Go仅支持循环关键字for。那么遍历数组肯定是for。 for循环123for i := 0; i &lt; len(a); i++ { t.Log(a[i])} foreach循环虽然Go中没有foreach关键字，但是也可以利用for关键字来实现类型foreach循环。 123for index, e := range a { t.Log(index, e)} 需要注意是索引不能省略，但是可以“_”来表示占位，这样就能即使不使用index，也不会报错。 123for _, e := range a { t.Log(e)} 下面我用代码来演示for循环和for实现的foreach循环： 11_array_test.go1234567891011121314151617181920212223func TestArrayEach(t *testing.T) { a := [3]int{1, 2, 3} for i := 0; i &lt; len(a); i++ { t.Log(a[i]) } // 那有没有类型Java或C#中的foreach: foreach(int i in a)，也是有的 for index, e := range a { t.Log(index, e) } // 那我们可不可以省略index? for e := range a { // 通过输出结果可以看到e是索引 t.Log(e) } // 好吧，那我把index写上，但是我不用它行不？这样肯定不行啊，会报错：Unused variable 'index' // Go中可以“_”表示占位，不使用它也不会报错 for _, e := range a { t.Log(e) }} 数组截取这个很好理解，请直接代码： 11_array_test.go1234567891011func TestArraySection(t *testing.T) { a := [...]int{1, 2, 3, 4, 5} t.Log(a, reflect.TypeOf(a)) // 数组截取：a[开始索引(包含), 不包含(不包含)] b := a[1:2] t.Log(b, reflect.TypeOf(b)) // 2 t.Log(a[1:3]) // 2 3 t.Log(a[1:]) // 2 3 4 5 t.Log(a[:3]) // 1 2 3} 1234567=== RUN TestArraySection 11_array_test.go:52: [1 2 3 4 5] [5]int 11_array_test.go:56: [2] []int 11_array_test.go:57: [2 3] []int 11_array_test.go:58: [2 3 4 5] 11_array_test.go:59: [1 2 3]--- PASS: TestArraySection (0.00s) 这里我们需要注意是，数组截取后就变成了slice切片了。 切片切片也是一个连续存储的数据结构。 切片内部结构它本质上是一个结构体。该结构体包括三个基本元素，分别是ptr、len、cap： ptr指针：指向连续的存储空间，也就是一个数组。 len 存了多少个元素个数。 cap 即capacity，指可以存多少个元素。指针指向的后端这个数组空间长度，比如5个元素的数组，这个cap可以是5。 概念似乎很难理解，下面我用代码来讲解怎么创建切片以及len和cap的区别： 11_slice_test.go12345678910111213141516171819202122232425262728func TestSliceInit(t *testing.T) { // 声明 var s0 []int t.Log(s0, len(s0), cap(s0)) s0 = append(s0, 1) t.Log(s0, len(s0), cap(s0)) t.Log(&quot;\\r&quot;) // 声明并初始化 s1 := []int{1, 2, 3, 4} t.Log(s1, len(s1), cap(s1)) s1 = append(s1, 5) t.Log(s1, len(s1), cap(s1)) t.Log(&quot;\\r&quot;) // 使用make创建 // 如果len大于cap则会报错：larger than cap in make([]int) //s2 := make([]int, 3, 0) s2 := make([]int, 3, 3) t.Log(s2, len(s2), cap(s2)) // panic: runtime error: index out of range [3] with length 3 [recovered] // panic: runtime error: index out of range [3] with length 3 //t.Log(s2[0], s2[1], s2[2], s2[3], s2[4]) for i := 0; i &lt; 10; i++ { s2 = append(s2, i) t.Log(s2, len(s2), cap(s2)) }} 12345678910111213141516171819=== RUN TestSliceInit 11_slice_test.go:8: [] 0 0 11_slice_test.go:10: [1] 1 1 11_slice_test.go:11: 11_slice_test.go:15: [1 2 3 4] 4 4 11_slice_test.go:17: [1 2 3 4 5] 5 8 11_slice_test.go:18: 11_slice_test.go:24: [0 0 0] 3 3 11_slice_test.go:30: [0 0 0 0] 4 6 11_slice_test.go:30: [0 0 0 0 1] 5 6 11_slice_test.go:30: [0 0 0 0 1 2] 6 6 11_slice_test.go:30: [0 0 0 0 1 2 3] 7 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4] 8 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4 5] 9 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4 5 6] 10 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4 5 6 7] 11 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4 5 6 7 8] 12 12 11_slice_test.go:30: [0 0 0 0 1 2 3 4 5 6 7 8 9] 13 24--- PASS: TestSliceInit (0.00s) 从上面的代码的输出结果可以得出： len为0，capacity也为0； 初始化后的切片，capacity等于len capacity必须大于或等于len； 如果len增长了，capacity不一定增长； 如果存放不下了元素，capacity则会以2倍增长。 下面用代码再演示下： 11_slice_test.go1234567func TestSliceGrowing(t *testing.T) { s := []int{} for i := 0; i &lt; 10; i++ { s = append(s, i) t.Log(s, len(s), cap(s)) }} 123456789101112=== RUN TestSliceGrowing 11_slice_test.go:38: [0] 1 1 11_slice_test.go:38: [0 1] 2 2 11_slice_test.go:38: [0 1 2] 3 4 11_slice_test.go:38: [0 1 2 3] 4 4 11_slice_test.go:38: [0 1 2 3 4] 5 8 11_slice_test.go:38: [0 1 2 3 4 5] 6 8 11_slice_test.go:38: [0 1 2 3 4 5 6] 7 8 11_slice_test.go:38: [0 1 2 3 4 5 6 7] 8 8 11_slice_test.go:38: [0 1 2 3 4 5 6 7 8] 9 16 11_slice_test.go:38: [0 1 2 3 4 5 6 7 8 9] 10 16--- PASS: TestSliceGrowing (0.00s) 不知你们有没有想过这样一个问题：如果一直以2倍增长，那样内存消耗将会越来越大，这样的增长肯定是不合理的。下面我将通过Go的源码来分析capacity增长规则。 capacity增长规则11_slice_test.go1234567891011121314func TestSliceCapGrowthRules(t *testing.T) { s := make([]int, 0) n := 0 for n &lt; 1500 { s = append(s, n) t.Log(color.White, len(s), cap(s)) if len(s)+1 &gt; cap(s) { t.Log(color.Red, &quot;下一个append将扩容&quot;) } n++ }} 下面的输出，capacity是2倍增长，符合上一节的总结。 123456789101112131415161718192021222324252627=== RUN TestSliceCapGrowthRules 11_slice_test.go:54: 1 1 11_slice_test.go:56: 下一个append将扩容 11_slice_test.go:54: 2 2 11_slice_test.go:56: 下一个append将扩容 11_slice_test.go:54: 3 4 11_slice_test.go:54: 4 4 11_slice_test.go:56: 下一个append将扩容 11_slice_test.go:54: 5 8 11_slice_test.go:54: 6 8 11_slice_test.go:54: 7 8 11_slice_test.go:54: 8 8 11_slice_test.go:56: 下一个append将扩容 11_slice_test.go:54: 9 16 11_slice_test.go:54: 10 16 11_slice_test.go:54: 11 16 11_slice_test.go:54: 12 16 11_slice_test.go:54: 13 16 11_slice_test.go:54: 14 16 11_slice_test.go:54: 15 16 11_slice_test.go:54: 16 16 11_slice_test.go:56: 下一个append将扩容 11_slice_test.go:54: 17 32 11_slice_test.go:54: 18 32 11_slice_test.go:54: 19 32 11_slice_test.go:54: 20 32 ... 但是当len大于1024的时候，capacity却变成了1280，不是两倍增长了。 12345678910111211_slice_test.go:54: 1020 102411_slice_test.go:54: 1021 102411_slice_test.go:54: 1022 102411_slice_test.go:54: 1023 102411_slice_test.go:54: 1024 102411_slice_test.go:56: 下一个append将扩容11_slice_test.go:54: 1025 128011_slice_test.go:54: 1026 128011_slice_test.go:54: 1027 128011_slice_test.go:54: 1028 128011_slice_test.go:54: 1029 128011_slice_test.go:54: 1030 1280 看来得看下Go的源码了。打开$GOROOT/src/runtime/slice.go，在growslice函数可以看到计算 newcap的算法。算法分为两步： 预估容量 内存对齐 第一步，预估新容量1234567891011121314151617181920212223242526272829303132333435363738// src/runtime/slice.go/* 参数分析： old 是老切片 cap 是新切片容量的最小值（即旧切片的容量加上新加入元素的数量）*/func growslice(et *_type, old slice, cap int) slice { // 1. 预估容量 newcap := old.cap doublecap := newcap + newcap // 首先判断，如果新切片容量的最小值（cap）大于2倍的旧容量（old.cap），则cap为新容量（newcap）。 if cap &gt; doublecap { newcap = cap } else { // 如果旧切片的长度小于1024，则最新容量就是旧容量的两倍，即 newcap=doublecap。 if old.len &lt; 1024 { newcap = doublecap } else { // 否则新容量以旧容量每次增长25%，直到新容量（newcap）大于或等于新切片容量的最小值。 // Check 0 &lt; newcap to detect overflow // and prevent an infinite loop. for 0 &lt; newcap &amp;&amp; newcap &lt; cap { newcap += newcap / 4 } // 如果新容量计算值溢出，则新容量为新切片容量的最小值。 // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap &lt;= 0 { newcap = cap } } } // 2. 内存对齐 roundupsize...} 预估容量只是预估的元素“个数”。那需要占用多少内存呢？ 第二步，内存对齐内存占用 = 预估容量 * 元素类型大小。 不过，由于 Go 语言的内存分配是由其 runtime 来管理的，程序并不是直接和操作系统打交道。在程序启动时，runtime 会提前向操作系统申请一批内存，按照不同的规格管理起来，如下所示（重点看 bytes/obj 这列）： 123456789101112131415161718192021222324// src/runtime/sizeclasses.go// Code generated by mksizeclasses.go; DO NOT EDIT.//go:generate go run mksizeclasses.gopackage runtime// class bytes/obj bytes/span objects tail waste max waste// 1 8 8192 1024 0 87.50%// 2 16 8192 512 0 43.75%// 3 32 8192 256 0 46.88%// 4 48 8192 170 32 31.52%// 5 64 8192 128 0 23.44%// 6 80 8192 102 32 19.07%// 7 96 8192 85 32 15.95%// 8 112 8192 73 16 13.56%// 9 128 8192 64 0 11.72%// 10 144 8192 56 128 11.82%// 11 160 8192 51 32 9.73%// ......// 23 448 8192 18 128 8.37%// 24 480 8192 17 32 6.82%// 25 512 8192 16 0 6.05%// 26 576 8192 14 128 12.33%// ...... 当程序向 runtime 申请内存时，它会匹配足够大，且最接近的规格。 示例1：元素为int32类型的切片11_slice_test.go1234567func TestSliceCapGrowthRules1(t *testing.T) { s := []int32{1, 2} t.Log(len(s), cap(s)) s = append(s, 3, 4, 5) t.Log(len(s), cap(s))} 11_slice_test.go1234=== RUN TestSliceCapGrowthRules1 11_slice_test.go:65: 2 2 11_slice_test.go:68: 5 8--- PASS: TestSliceCapGrowthRules1 (0.00s) cap(2 + 3) &gt; doublecap(2 * 2) ，所以预估新容量为5。 int32 占用 4 byte，总内存占用为 5 * 4=20 byte，则 runtime 实际分配的内存为 32 byte，最终的容量为 32 / 4（每个 int 32 占用大小） = 8。 示例2：元素为int64类型的切片如果将上面例子的 int32 改为 int64，得到的结果会是怎样的呢？ cap(2 + 3) &gt; doublecap(2 * 2)，所以预估新容量为5。 int64 占用 8 byte，总内存 5 * 8 = 40 byte，runtime 实际分配 48 byte，48 / 8 = 6。 示例3：append另一个切片11_slice_test.go12345678910func TestSliceCapGrowthRules3(t *testing.T) { a := make([]int, 20) t.Log(len(a), cap(a)) b := make([]int, 42) t.Log(len(b), cap(b)) a = append(a, b...) t.Log(len(a), cap(a))} 前面z总结过“初始化后的切片，capacity等于len”，cap(20 + 42) &gt; doublecap(2 * 20)，因此预估新容量为62。 由于我是在64位的机器上运行的，因此int为int64，int64占8个字节，所以总内存为 62 * 8 = 496，在内存规格中会选择512，所以新容量为 512 / 8 = 64。 12345=== RUN TestSliceCapGrowthRules3 11_slice_test.go:81: 20 20 11_slice_test.go:84: 42 42 11_slice_test.go:87: 62 64--- PASS: TestSliceCapGrowthRules3 (0.00s) 示例4：元素为string的切片11_slice_test.go12345678910func TestSliceCapGrowthRules4(t *testing.T) { var s string t.Log(unsafe.Sizeof(s)) a := []string{&quot;My&quot;, &quot;name&quot;, &quot;is&quot;} t.Log(len(a), cap(a)) a = append(a, &quot;jason&quot;) t.Log(len(a), cap(a))} cap(3 + 1) &lt; doublecap(2 * 3)，因此预估新容量为6。 64位下string占16个字节，总内存为 6 * 16 = 96 byte，匹配到的内存规格为96字节，所以最终扩容后容量为 96 / 16 = 6。 12345=== RUN TestSliceCapGrowthRules4 11_slice_test.go:102: 16 11_slice_test.go:105: 3 3 11_slice_test.go:108: 4 6--- PASS: TestSliceCapGrowthRules4 (0.00s) 总结graph TB a[新切片len > 旧切片cap] --> |是|b(扩容) a --> |否|b1(不扩容) b --> c[预估新容量newcap] c --> d{新切片容量最小值 > 2倍旧容量} d --> |是| e[newcap = 新切片容量最小值] d --> |否| e1{旧切片长度小于1024} e1 --> |是| f[newcap = 2倍旧容量] e1 --> |否| f1[新切片在旧切片容量上每次增长25%直到newcap >= 新切片容量的最小值] e --> g[内存对齐] f --> g f1 --> g g --> h[预估内存占用 = 预估容量 * 元素类型大小] h --> i[匹配到runtime申请的内存规格对应的内存] i --> j[newcap = 匹配到的内存 / 元素类型大小] classDef mainStep fill:#02d7f2,color:#000 class c,g mainStep 切片共享存储结构切片是一个共享存储结构。还是用代码说话： 11_slice_test.go123456789101112131415func TestSliceShareMemory(t *testing.T) { year := []string{&quot;Ja&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;} t.Log(year, len(year), cap(year)) summer := year[4:7] // 为什么summer的capacity是8呢？ // 虽然截取到索引6为止，但是summer是指向连续的存储空间year，也就是从year索引4开始到year最后一个元素的这一段连续空间 // 也就是从May到Dec，总共8个，capacity也就是8。 // 如果还觉得很绕，可以先这样记，后面我也会讲到，到时候进一步消化。 t.Log(summer, len(summer), cap(summer))// [May Jun Jul] 3 8 summer[0] = &quot;Unknown&quot; t.Log(summer, len(summer), cap(summer)) t.Log(year, len(year), cap(year))} 123456=== RUN TestSliceShareMemory 11_slice_test.go:46: [Ja Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec] 12 12 11_slice_test.go:53: [May Jun Jul] 3 8 11_slice_test.go:56: [Unknown Jun Jul] 3 8 11_slice_test.go:57: [Ja Feb Mar Apr Unknown Jun Jul Aug Sep Oct Nov Dec] 12 12--- PASS: TestSliceShareMemory (0.00s) 通过输出结果可以得知：切片是引用类型。 数组和切片的区别 容量 数组之间比较 类型 数组 不可伸缩 可比较 值类型 切片 可伸缩 不可比较 引用类型 为了防止篇幅过长，这里只用代码演示下切片的比较，后面我会抽时间具体讲解下。 123456789func TestSliceComparing(t *testing.T) { a := []int{1, 2, 3} b := []int{1, 2, 3} // 语法报错：Invalid operation: a == b (operator == is not defined on []int) // 编译时报错：invalid operation: a == b (slice can only be compared to nil) //if a == b { // t.Log(&quot;equal&quot;) //}} 参考 Go slice 扩容机制分析 终于理解了Slice扩容机制 【Golang】slice类型存什么？make和new？slice和数组？扩容规则？","link":"/p/53ed3754/"},{"title":"Uploading and copy download command for transfer.sh","text":"本文是我给 transfer.sh 提的一个 PR 的内容。 Download commands can be automatically copied to the clipboard after files are uploaded using transfer.sh. It was designed for 🐧 Linux or 🍎 macOS. 1. Install xclip or xsel for Linux, macOS skips this step install xclip see https://command-not-found.com/xclip install xsel see https://command-not-found.com/xsel Install later, add pbcopy and pbpaste to .bashrc or .zshrc or its equivalent. If use xclip, paste the following lines: 12alias pbcopy='xclip -selection clipboard'alias pbpaste='xclip -selection clipboard -o' If use xsel, paste the following lines: 12alias pbcopy='xsel --clipboard --input'alias pbpaste='xsel --clipboard --output' 2. Add Uploading and copy download command shell function Open .bashrc or .zshrc or its equivalent. Add the following shell script: 1234567891011121314151617181920transfer() { curl --progress-bar --upload-file &quot;$1&quot; https://transfer.sh/$(basename &quot;$1&quot;) | pbcopy; echo &quot;1) 🔗 Download link:&quot; echo &quot;$(pbpaste)&quot; echo &quot;\\n2) 🐧 Linux or 🍎 macOS download command:&quot; linux_macos_download_command=&quot;wget $(pbpaste)&quot; echo $linux_macos_download_command echo &quot;\\n3) 😓 Windows download command:&quot; windows_download_command=&quot;Invoke-WebRequest -Uri &quot;$(pbpaste)&quot; -OutFile $(basename $1)&quot; echo $windows_download_command case $2 in l|m) echo $linux_macos_download_command | pbcopy ;; w) echo $windows_download_command | pbcopy ;; esac} 3. TestThe transfer command has two parameters: The first parameter is the path to upload the file. The second parameter indicates which system’s download command is copied. optional: This parameter is empty to copy the download link. l or m copy the Linux or macOS command that downloaded the file. w copy the Windows command that downloaded the file. For example, The command to download the file on Windows will be copied: 12345678910$ transfer ~/temp/a.log w######################################################################## 100.0%1) 🔗 Download link:https://transfer.sh/y0qr2c/a.log2) 🐧 Linux or 🍎 macOS download command:wget https://transfer.sh/y0qr2c/a.log3) 😓 Windows download command:Invoke-WebRequest -Uri https://transfer.sh/y0qr2c/a.log -OutFile a.log","link":"/p/d03eb810/"},{"title":"记住VS Code这些快捷键，保证提高你的编程效率（持续更新）","text":"VS Code 功能真的很强大，但是我还是仅仅用于文本或代码编辑，因为它相对于 JetBrains 开发的 IDE 还不够专业。虽然仅仅只是文本和代码编辑，但也使用非常频繁，VS Code 提供的快捷键相当全面，因此记住这些快捷键将大大提高编辑效率。 复制、删除 快捷键 描述 Shift + Option + 上或下 复制光标所在行到光标的上或下一行 Command + Shift + K 删除当前行 选择 快捷键 描述 Ctrl + Shift + 左 缩小选择 Shrink selection Ctrl + Shift + 右 展开选择 Expand selection 多光标编辑 快捷键 描述 Command + Shift + L 多光标同时编辑选中相同的内容或光标所在的单词 Command + D 按一下，选中光标所在的单词；再按一下，选中下一个相同的单词 Command + U 光标撤销 Command + K + D 移除当前选中，选中下一个相同的 参考链接https://code.visualstudio.com/docs/editor/codebasics#_keyboard-shortcuts","link":"/p/7beffdb5/"},{"title":"WebStorm 调试 Node.js 项目","text":"我们很多项目都用到了 Node.js，比如MQTT服务器、对外服务、天猫精灵服务等。Node.js 项目 IDE 切换到WebStorm，记录一下 WebStorm 如何配置调试 Node.js 项目。 项目是使用常规命令运行的，即node Server.js想要实现断点调试的操作方法如下： 打开Run/Debug Configurations。 添加Nodejs Configuration。 配置JavaScript file。我这里运行的Server.js文件，所以这里配置为Server.js","link":"/p/4105bd36/"},{"title":"forever 如何查看当前运行的 Node.js 应用所在的目录","text":"有时候我们可能会忘记 forever start 所执行的 js 文件所在的目录，那么怎么最快获取 js 文件所在的目录呢？ 解决 我们先尝试使用forever list 。通过上图执行的结果，可以看到输出了forever start 的 js 文件，上图为Server.js，但是没有Server.js所在的目录 给forever list输出结果添加 js 文件所在目录列。 执行如下命令： bash1forever columns add dir 再执行forever list。这时我们就能看到输出的结果包含了js文件所在目录的列。 参考链接： 使用forever运行nodejs应用 https://stackoverflow.com/questions/19292326/node-js-forever-module-get-path-to-a-script-that-is-running","link":"/p/23877d9/"},{"title":"Provisioning profile xxx doesn&#39;t include signing certificate Apple Distribution: xxx Technology Co., Ltd. (H6GCWZCE8G).","text":"不得不说 Apple 的开发者证书设计的很差（非自动管理证书方式）。你看又遇到了此问题： 解决方法 按下 Command + 空格 打开聚焦搜索。 粘贴 ~/Library/MobileDevice/Provisioning Profiles。 选择该文件夹，按下 Comand + Enter，在访达中打开。 根据 Provisioning Profile 名称找到对应的 mobileprovision 文件。 选择该文件，按下空格查看文件信息。 通过该文件可以得知 CERTIFICATES Name 。 打开 Xcode 中的 Build Settings，找到 Sining -&gt; Code Signing Identity -&gt; Release 选择 CENTIFICATES Name，问题即可解决。","link":"/p/9b65512f/"},{"title":"解决 Node.js 项目报 SyntaxError: Unexpected token ... 错误","text":"问题我们的天猫精灵服务是用 Node.js 做的。 今天在该项目中添加一个包nzh，我是在 package.json 里面直接添加的，然后运行 npm install，运行后会安装nzh包，同时也会更新其他需要更新的包。 然后 Debug，测试通过没有问题，接着发布到服务器上。服务器上运行 forever start xx.js，竟然 stopped。 看了下log，竟然报错了，测试环境没有问题，生产环境却报错了。 报错如下： 1234567891011121314151617181920/xxx/node_modules/mqtt/node_modules/ws/lib/websocket.js:345 ...options ^^^SyntaxError: Unexpected token ... at Object.exports.runInThisContext (vm.js:76:16) at Module._compile (module.js:542:28) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/xxx/node_modules/mqtt/node_modules/ws/index.js:3:19) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) SyntaxError: Unexpected token ...翻译中文为：语法错误:意外的标记 很明显报错的为...，语法错误，这肯定是ES特性不支持的问题，不支持那就是Node.js的版本的问题 解决 查看服务器Node.js版本为6.9.2 查看测试环境Node.js版本为12.13.1 果然版本不一致，考虑到服务器的 Node.js 版本确实有点低了，决定升级到最新稳定版本 安装 Node.js 版本管理工具1npm install -g n 安装最新稳定版 node1npm lts 使用 n 切换版本123456$ n node/6.9.2 node/10.16.3 ο node/12.13.1Use up/down arrow keys to select a version, return key to install, d to delete, q to quit 查看Node.js版本 奇怪了，没有切换成功通过搜索找到了原因： n 默认安装路径是 /usr/local，若你的 node 不是在此路径下，n 切换版本就不能把bin、lib、include、share 复制该路径中，所以我们必须通过N_PREFIX变量来修改 n 的默认node安装路径。 通过 which 命令查看命令所在的路径。 which: 常用于查找可直接执行的命令。只能查找可执行文件，该命令基本只在$PATH路径中搜索，查找范围最小，查找速度快。默认只返回第一个匹配的文件路径，通过选项 -a 可以返回所有匹配结果。 具体请参考 node.js版本管理工具n无效的原理和解决方法 启动Node.js服务1forever start xxx.js 启动成功了，解决完成。 思考问题虽然是解决了。或许你会有更多疑问了❓❓❓ …操作符是什么？ …操作符真的不支持 node v6.9.2 吗？ 考虑到…操作符要介绍的内容较多，就不在这篇文章中写了。请看下篇文章《JavaScript…延展操作符(Spread operator)》。","link":"/p/c19f3473/"},{"title":"JavaScript … 延展操作符(Spread operator)","text":"上一篇文章 解决 Node.js 项目报 SyntaxError: Unexpected token … 错误 - 干志雄的博客 就是因为…操作符导致运行报错了，本文将介绍…操作符和解答上一篇文章中的思考问题。 … 操作符英文叫 Spread operator，即延展操作符。该操作符从 ES6 开始支持。ES9 中也新增了些特性。 ES6 延展操作符(Spread operator)的特性ES6 即 ECMAScript 2015 规范。 延展操作符…，从ES6开始添加的。 可以在函数调用/数组构造时, 将数组表达式或者 string 在语法层面展开； 还可以在构造对象时, 将对象表达式按key-value的方式展开。 语法函数调用1myFunction(...iterableObj); 数组构造或字符串：123var iterableObj = [0, 1, 2, 3];[...iterableObj, '4', ...'hello', 6];(11) [0, 1, 2, 3, '4', 'h', 'e', 'l', 'l', 'o', 6] 应用场景在函数调用时使用延展操作符12345678910function sum(x, y, z) { return x + y + z;}const numbers = [1, 2, 3];//不使用延展操作符console.log(sum.apply(null, numbers));// 6//使用延展操作符console.log(sum(...numbers));// 6 Rest 参数和扩展运算符ES2015 引入了 Rest 参数和扩展运算符。三个点（…）仅用于数组。Rest 参数语法允许我们将一个不定数量的参数表示为一个数组。 12345678910function restParam(p1, p2, ...p3) { console.log(p1); // p1 = 1 console.log(p2); // p2 = 2 console.log(p3); // p3 = [3, 4, 5]}restParam(1, 2, 3, 4, 5); 展开操作符展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如Math.max()返回给定数字中的最大值： 12345/** * Returns the larger of a set of supplied numeric expressions. * @param values Numeric expressions to be evaluated. */max(...values: number[]): number; 12const values = [99, 100, -1, 48, 16];console.log( Math.max(...values) ); // 100 构造数组没有展开语法的时候，只能组合使用 push，splice，concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法, 构造新数组会变得更简单、更优雅。 和参数列表的展开类似, … 在构造字数组时, 可以在任意位置多次使用。 123const stuendts = ['Jine','Tom']; const persons = ['Tony',... stuendts,'Aaron','Anna'];conslog.log(persions)// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;] 连接多个数组 12345var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];var arr3 = [...arr1, ...arr2];// 将 arr2 中所有元素附加到 arr1 后面并返回//等同于var arr4 = arr1.concat(arr2); 数组拷贝展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。 1234var arr = [1, 2, 3];var arr2 = [...arr]; // 等同于 arr.slice()arr2.push(4); console.log(arr2)//[1, 2, 3, 4] 在React中的应用通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props 。但是当传递大量的props时，会非常繁琐，这时我们可以使用 …(延展操作符,用于取出参数对象的所有可遍历属性) 来进行传递。 一般情况下我们应该这样写。 1&lt;CustomComponent name ='Jine' age ={21} /&gt; 使用 … ，等同于上面的写法。 12345const params = { name: 'Jine', age: 21}&lt;CustomComponent {...params} /&gt; 配合解构赋值避免传入一些不需要的参数。 1234567891011var params = { name: '123', title: '456', type: 'aaa'}var { type, ...other } = params;&lt;CustomComponent type='normal' number={2} {...other} /&gt;//等同于&lt;CustomComponent type='normal' number={2} name='123' title='456' /&gt; ES9延展操作符(Spread operator)的特性ES9 即 ECMAScript 2018 规范。 ES9 中 Spread operator 有关联的特性是： object spread properties，即延展操作符增加了对对象的支持。 object rest properties，即 Rest 参数添加了对对象的支持。 语法构造对象时，进行克隆或者属性拷贝。但是这只是一个对象的浅拷贝。因此，如果一个对象 A 的属性是对象 B ，那么在克隆后的对象 cloneB 中，该属性指向对象 B。 1234&gt; let a = 'a'; let b = {...a}undefined&gt; b{ '0': 'a' } 1234&gt; let array = ['a', 'b', 'c']; let copyArray = {...array}undefined&gt; copyArray{ '0': 'a', '1': 'b', '2': 'c' } 123456789101112&gt; let obj = {a: 0, b: 1, c: 2}; let objClone = {...obj};undefined&gt; objClone{ a: 0, b: 1, c: 2 }&gt; obj == objClonefalse&gt; obj[a] = -1-1&gt; obj{ a: -1, b: 1, c: 2 }&gt; objClone{ a: 0, b: 1, c: 2 } 合并对象1234var obj1 = { foo: 'bar', x: 42 };var obj2 = { foo: 'baz', y: 13 };var mergedObj = { ...obj1, ...obj2 };// 合并后的对象: { foo: &quot;baz&quot;, x: 42, y: 13 } 对象解构提供了和数组一样的Rest参数（）和展开操作符。 123456789const myObject = { a: 1, b: 2, c: 3};const { a, ...x } = myObject;// a = 1// x = { b: 2, c: 3 } 或者你可以使用它给函数传递参数： 123456789101112function restParam({ a, ...x }) { console.log(a); // a = 1 console.log(x); // x = { b: 2, c: 3 }}restParam({ a: 1, b: 2, c: 3}); 跟数组一样，Rest 参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。 如何知道node的版本是否支持ES特性通过 node.green 这个网站可以查询到 ES 特性是否支持 node 版本。 例如，我现在用的 node 版本为 v6.9.2，我要判断是否支持 object spread properties 这个特性？其实有两个方法。 通过node.green查找通过 node.green，找到 object spread properties，可以看到只有 8.6 及以上的版本才支持。 通过代码测试验证 在 node 版本为 6.9.2 下验证。 可以看到let b = {...a}输入回车后，只有三个.，没有任何提示了。 123456789101112131415161718$ node &gt; let a = 'a'undefined&gt; let b = {...a}... &gt; bReferenceError: b is not defined at repl:1:1 at sigintHandlersWrap (vm.js:22:35) at sigintHandlersWrap (vm.js:96:12) at ContextifyScript.Script.runInThisContext (vm.js:21:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12) at REPLServer.&lt;anonymous&gt; (repl.js:513:10) at emitOne (events.js:101:20) at REPLServer.emit (events.js:188:7)&gt; 在 node 版本为 10.16.3 下验证。 木有问题，测试通过。 12345678910111213# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog on git:master x [23:42:57] $ node -v v10.16.3# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/Documents/blog on git:master x [23:43:01] $ node &gt; let a = 'a'undefined&gt; let b = {...a}undefined&gt; b{ '0': 'a' }&gt; 参考链接 ES6、ES7、ES8、ES9、ES10新特性一览 相信你看完本文，应该已经知道上一篇文章 解决 Node.js 项目报 SyntaxError: Unexpected token … 错误 - 干志雄的博客 最后留下的思考问题的答案了。","link":"/p/bda54489/"},{"title":"hexo s 报错 FATAL { err: TypeError: line.matchAll is not a function","text":"今天执行 hexo s 启动服务时报如下错误： 1234FATAL { err: TypeError: line.matchAll is not a function at res.value.res.value.split.map.line (/Users/ganzhixiong/Documents/blog/node_modules/hexo-util/lib/highlight.js:128:26) at Array.map (&lt;anonymous&gt;) 网上关于此问题其实没有我讲的详情和清楚，不妨看看我的解题思路。 matchAll is not a function 这个错误其实很明显，意思就是找不到 matchAll 这个函数。我猜想是当前 Node.js 版本不支持 matchAll 这个函数，下面我们验证下。 定位到报错代码行列 128:26。 1234567891011res.value = res.value.split('\\n').map(line =&gt; { const prepend = tokenStack.map(token =&gt; `&lt;span class=&quot;${token}&quot;&gt;`).join(''); // 定位到如下行。 const matches = line.matchAll(/(&lt;span class=&quot;(.*?)&quot;&gt;|&lt;\\/span&gt;)/g); for (const match of matches) { if (match[0] === '&lt;/span&gt;') tokenStack.shift(); else tokenStack.unshift(match[2]); } const append = '&lt;/span&gt;'.repeat(tokenStack.length); return prepend + line + append;}).join('\\n'); 通过代码可以得知 line 是一个字符串，那么 matchAll 是 string 的一个函数。 查看 matchAll 这个特性哪个版本的 Node.js 支持。 打开 Node.js ES2015/ES6, ES2016 and ES2017 support 搜索 matchAll。 可以看到 String.prototype.matchAll 是从 ES2020 开始支持的，只有 Node.js 版本大于等于 12.0.0 才支持该功能。 String.prototype.matchAll()matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。 查看并切换或升级你的 Node.js 版本。 我使用的是 n 这个工具管理 node 版本，它使用非常简单。用 npm i -g n 全局安装 n，用 n --help 查看如何使用。 123456789101112$ node -v v10.16.3$ n node/6.9.2 node/10.16.3 ο node/12.13.1Use up/down arrow keys to select a version, return key to install, d to delete, q to quit$ node -vv10.16.3","link":"/p/81f9e8f0/"},{"title":"命令行中的文件名或目录名若包含&quot;#&quot;号，别忘了添加转义","text":"12345$ mkdir c#zsh: no matches found: c#$ cd ./c#zsh: no matches found: ./c# 123456789101112131415161718192021222324252627282930$ mkdir c#zsh: no matches found: c## ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/temp [16:34:21] C:1$ mkdir c\\## ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/temp [16:34:42] $ ltotal 472drwxr-xr-x 10 ganzhixiong staff 320B Oct 15 16:34 .drwxr-xr-x+ 178 ganzhixiong staff 5.6K Oct 15 16:34 ..-rw-r--r--@ 1 ganzhixiong staff 54K Sep 11 00:47 1.log-rw-r--r-- 1 ganzhixiong staff 545B Sep 16 11:16 2.log-rw-r--r-- 1 ganzhixiong staff 54K Sep 16 11:18 3.log-rw-r--r-- 1 ganzhixiong staff 54K Sep 16 11:21 4.log-rw-r--r-- 1 ganzhixiong staff 30B Sep 17 15:53 a.logdrwxr-xr-x 2 ganzhixiong staff 64B Oct 15 16:34 c#-rw-r--r-- 1 ganzhixiong staff 54K Sep 11 00:47 hs_err_pid1391.log-rw-r--r-- 1 ganzhixiong staff 17B Sep 16 12:08 苹果.log# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/temp [16:34:45] $ cd c# zsh: no matches found: c## ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/temp [16:36:38] C:1$ cd c\\#/# ganzhixiong @ ganzhixiongdeMacBook-Pro-3 in ~/temp/c# [16:36:42] $ echo &quot;hello&quot; # Linux 命令行或 Shell 中 # 号表示为注释，因此这样写不会报错hello","link":"/p/e77371fa/"},{"title":"Node.js 可以用来做什么？","text":"Node.js 借助 JavaScript 这么语言，已经在各个领域百花齐放了。 尤其是在 Web 服务、构建工作流、Electron 这三个领域已经广泛使用。下面我将介绍 Node.js 在这些领域的应用和优势。 Web服务 搜索引擎优化 + 首屏速度优化 = 服务端渲染即SSR（Server Side Rendering） 前后端同构（模板复用）。 BFF（Backend For Frontend）。 构建工作流在没有 Gulp 和 webpack 等构建工具之前，前端工程师可能会用 java、ruby、shell 做一些构建工具，而这些语言对于前端工程师不是那么熟练，而用 Node.js 做构建工具，前端工程师将更容易的查找、修改、扩展构建工具。 Gulpgulp 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。从上图的例子我们可以看出它能给 html、css、js 做一些如下预处理： 编译和整理 Pug 文件为相应的 HTML 文档。 将 less 文件编译为 css 文件。 将 js 文件打包压缩、混淆为一个文件。 webpackwebpack 通过一些规范把 js、css、图片等打包在一起，这样就能减少前端尽可能少的 HTTP 连接，加速网页的加载。 KttDeploy我司开发的 KttDeploy 就是用 Node.js 写的，用于打包 H5 资源文件给 App 调用。 ElectronElectron 基于 Chromium 和 Node.js， 让你可以使用 HTML、CSS 和 JavaScript 构建兼容 Mac、Windows 和 Linux 的桌面应用程序。 在用 Electron 之前我用过 Delphi、C# 开发 Windows 桌面应用。尤其使用 C# 开发了很多企业级应用，C# 也确实方便，但是要跨平台就难了。如果应用只运行在 Windows 上，用陈旧的 Winform 的话，要做出好看的 UI 又有一定难度且没有 Web 开发效率高，所以只考虑运行在 Windows 上，又要做出好看的 UI，那就用 WPF 吧！ Electron 的优势Web技术因为 Electron 基于 Chromium 和 Node.js，如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 开源Electron 是一个由 GitHub 及众多贡献者组成的活跃社区共同维护的开源项目。 跨平台Electron 兼容 Mac、Windows 和 Linux，可以构建出三个平台的应用程序。 使用 Electron 开发的 Apps Visual Studio Code Facebook Messenger Twitch Microsoft Teams InVison 等等，实在是太多了我用 Electron 开发的桌面应用我之前公司开发的一款即插即用触摸输入密码的 USB 工具 HelloKey，且该工具就是通过 Node.js 和设备进行HID通信，支持macOS、Windows、Linux。","link":"/p/322367d4/"},{"title":"用 status 还是 state？","text":"相信你在写代码的时候，在定义一个变量表示状态时，不知道变量名称该用 status 还是 state？因为这两个单词都是表示状态。 规范编程的细节很重要，能看出你对编程的热爱、对工作的负责、对完美的追求，以及你的英语水平。 status美 [ˈstætəs] 英 [‘steɪtəs] **n.**地位；身份；情形；法律地位（或身份） 网络状态；状况；状态栏 复数：statuses state美 [steɪt] 英 [steɪt] **n.**状态；国家；状况；州 **v.**说明；陈述；声明；规定 **adj.**国家提供（或控制）的；国事礼仪（或规格）的；州的；邦的 网络状态模式；政府；情形 复数：states 现在分词：stating 过去式：stated status 和 state 表示状态的区别军事题材相关的美剧中，上级让下级汇报任务执行情况时说的都是“status report”，任务的执行是有流程的、有先后顺序的。 总结：status 一般用在流程里（开始、进行中、结束），state 一般用来描述物质的状态（液体、固体、气体）。","link":"/p/a3fbbd0f/"},{"title":"请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接","text":"今天在 Win11 虚拟机中安装好 SQL Server 2019，就立马测试下项目中的程序，首先配置下数据库连接，测试连接确保如下错误： 1在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) (Microsoft SQL Server，错误: 2) 下面直接记录解决步骤： 从报错来看，很明显是实例名称不正确。 因此我在 SQL Server Management Studio 中尝试将服务器名称改为 ip、127.0.0.1、(local)，测试发现都报这个错误。 打开 Sql Server Configuration Manager（SQL Server 2019 配置管理器）。 将 SQLEXPRESS 的 TCP/IP 协议修改为启用。 双击 TCP/IP 协议，将 IPAll 的 TCP 端口修改为 1433。 重启 SQL Server(SQLEXPRESS) 服务。 再试会发现问题解决。","link":"/p/361818bb/"},{"title":"Visual Studio 如何将项目中目录下的文件复制到输出目录的根目录下？","text":"在做 C# 工程的时候，有些外部文件需要复制到输出目录（Debug/Release） 下。比如我们很多项目的数据库配置工具，就是另一个单独工程编写的，因为数据库配置工具它是由两个文件组成，一个是可执行文件，另一个是数据库配置文件。这时候如果你把这个文件放到项目指定目录下，然后设置这两个文件为 复制到输出目录，编译后会将这两个文件所在的目录结构也复制到 Debug 或 Release 目录，也就是复制了 db-config 这整个目录到输出目录下。 然后我只想让这两个文件输出到输出目录的根目录下面。那么怎么做呢？ 方法一将这两个外部文件放到项目的根目录下面，然后设置为复制到输出目录，编译后这两个文件将复制到 Debug 或 Release 根目录下面。 方法二打开 xxx.csproj 文件，将 修改为 ，并添加 ，再次编译就能看到效果。 xxx.csproj12345678910&lt;ItemGroup&gt; &lt;ContentWithTargetPath Include=&quot;db-config\\config.xml&quot;&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;TargetPath&gt;config.xml&lt;/TargetPath&gt; &lt;/ContentWithTargetPath&gt; &lt;ContentWithTargetPath Include=&quot;db-config\\奥图威尔数据库配置.exe&quot;&gt; &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt; &lt;TargetPath&gt;奥图威尔数据库配置.exe&lt;/TargetPath&gt; &lt;/ContentWithTargetPath&gt;&lt;/ItemGroup&gt; 请注意，此条目在Visual Studio（2012、2015、2017）中可能不可见，但是一旦手动添加到 csproj 中，它将显示在 Visual Studio 中。但是，目标路径 TargetPath 将无法通过 UI 进行编辑。 参考 c# - Visual Studio: How to &quot;Copy to Output Directory&quot; without copying the folder structure? - Stack Overflow","link":"/p/76b05e8a/"},{"title":"解决Sourcetree 无法获取 GitHub 远端组织中的仓库","text":"使用 Sourcetree 可以让你将更多精力和时间放在编写代码上，它能大大提供生产力。 之前 GitHub 上的仓库一直都是通过 Git 命令克隆下来的，想着就那么几行命令，也不耽误时间。但是今天突然要拉取某一个组织中的仓库，但是一时想不起来仓库名称，于是便想到 Sourtree 的主界面的远端功能可以搜索仓库，而且可以不执行命令行通过 UI 操作就能完成克隆，这样可以节省点时间，何不试试呢！由于个人仓库列表有点多，于是尝试几个关键字发现搜索不到，后来连组织名称都不在列表中。 于是便有这篇文章。 通过 Google 我在 Sourtree 官网找到了答案：Sourcetree for Mac GitHub 帐户权限。 下面我直接我将原答案直接整理为如下： 前往 https://github.com/settings/tokens。 单击“Generate new token”。 输入令牌描述，例如“sourcetree-mac”，修改过期时间为“No expiration”或你想要的时间，选中“repo”复选框，然后单击“生成令牌”。 复制生成的令牌。 将您的 GitHub 帐户添加到 Sourcetree，但现在不使用 OAuth，而是选择基本身份验证。 输入您的用户名。 将生成的令牌粘贴为密码。 现在，您的 GitHub 帐户和 Sourcetree 之间应该有一个功能齐全的连接，包括对所有私有存储库的访问。如果您遇到任何不起作用的功能（我没有），请尝试使用更多权限重新生成令牌 - 我特意只选择了“repo”，因为这是我目前所需要的。 希望这是有帮助的，直到 Sourcetree 团队修复。如上所述，该问题已在此处提交 https://jira.atlassian.com/browse/SRCTREE-6322。","link":"/p/a1fb3034/"},{"title":"记录 Visual Studio 2019 易忘的默认记快捷键及自定义快捷键","text":"如有默认快捷键，则添加快捷键是通过 BetterTouchTool 添加的。 名称 描述 默认快捷键 添加快捷键 编辑.复制 重复光标所在行、重复选中内容 ctrl + e, v 编辑.滚动行到中央 ctrl + l（同 JetBrains，需要移除编辑.剪切行快捷键）","link":"/p/2486fd02/"},{"title":"使用 GitHub Skyline API 获取 GitHub 用户贡献（翻译）","text":"对于像我这样喜欢收集自己的个人指标的人来说，2021 年是个好年头。早些时候，我聊了收集空气质量数据、Twitter 数据——以及现在的 GitHub 贡献数据。在这篇文章中，我将描述一种简单的方法来获取你自己的 GitHub 贡献统计数据，而不必跳过太多圈套。 GitHub 有一个漂亮的可视化工具，称为 Skyline，它允许根据用户的 GitHub 贡献图生成 3D 模型。你知道，你 GitHub 个人资料上的那些绿色方块吗？ Skyline 使它们看起来像这样： 想要！但是看到这一点，我问自己 - 是否有一个 API 可以让我以与该工具相同的方式获得贡献？肯定有很多第三方软件包可以做到这一点，但这意味着依赖我不知道的代码（在这种情况下并不是那么重要）。 答案一直在网络督察里！API 就这么简单： 1https://skyline.github.com/dend/2020.json 对此端点的请求会生成一个格式良好的 JSON，它提供了我的活动的非常详细的细分（当然是汇总的）： 不仅如此，API 还提供了诸如每年贡献量中位数、最大贡献计数、p80、p90 和 p99 百分位值等预先计算的统计数据。整洁的！我们无需验证或处理 GraphQL 即可获得所有这些。有了这些数据，我现在可以对自己的数字进行切片和切块，并以我想要的任何方式将它们可视化。 在你问之前，是的，这个 API 会返回用户在 GitHub 上活跃的任何年份的值。对我来说，它一直追溯到 2012 年。 本文翻译自：Get GitHub User Contributions With GitHub Skyline API | Den Delimarsky","link":"/p/80561f8f/"}],"tags":[{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"YAML Front Matter","slug":"YAML-Front-Matter","link":"/tags/YAML-Front-Matter/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"go-mssqldb","slug":"go-mssqldb","link":"/tags/go-mssqldb/"},{"name":"go-color","slug":"go-color","link":"/tags/go-color/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"新冠疫苗","slug":"新冠疫苗","link":"/tags/%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97/"},{"name":"净水器","slug":"净水器","link":"/tags/%E5%87%80%E6%B0%B4%E5%99%A8/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"grep","slug":"grep","link":"/tags/grep/"},{"name":"wc","slug":"wc","link":"/tags/wc/"},{"name":"pipe","slug":"pipe","link":"/tags/pipe/"},{"name":"Telnet","slug":"Telnet","link":"/tags/Telnet/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Microsoft Remote Desktop","slug":"Microsoft-Remote-Desktop","link":"/tags/Microsoft-Remote-Desktop/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"SQL Server","slug":"SQL-Server","link":"/tags/SQL-Server/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Navicat","slug":"Navicat","link":"/tags/Navicat/"},{"name":"in","slug":"in","link":"/tags/in/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"LFS","slug":"LFS","link":"/tags/LFS/"},{"name":"GoLand","slug":"GoLand","link":"/tags/GoLand/"},{"name":"GOPATH","slug":"GOPATH","link":"/tags/GOPATH/"},{"name":"GoPath","slug":"GoPath","link":"/tags/GoPath/"},{"name":"GoRoot","slug":"GoRoot","link":"/tags/GoRoot/"},{"name":"iota","slug":"iota","link":"/tags/iota/"},{"name":"PowerShell","slug":"PowerShell","link":"/tags/PowerShell/"},{"name":"tail","slug":"tail","link":"/tags/tail/"},{"name":"Get-Content","slug":"Get-Content","link":"/tags/Get-Content/"},{"name":"Xcode","slug":"Xcode","link":"/tags/Xcode/"},{"name":"Zsh","slug":"Zsh","link":"/tags/Zsh/"},{"name":"Oh My Zsh","slug":"Oh-My-Zsh","link":"/tags/Oh-My-Zsh/"},{"name":"Slice","slug":"Slice","link":"/tags/Slice/"},{"name":"Mermaid","slug":"Mermaid","link":"/tags/Mermaid/"},{"name":"乔月","slug":"乔月","link":"/tags/%E4%B9%94%E6%9C%88/"},{"name":"Children","slug":"Children","link":"/tags/Children/"},{"name":"Binary","slug":"Binary","link":"/tags/Binary/"},{"name":"Octal","slug":"Octal","link":"/tags/Octal/"},{"name":"Decimal","slug":"Decimal","link":"/tags/Decimal/"},{"name":"Hex","slug":"Hex","link":"/tags/Hex/"},{"name":"Win10","slug":"Win10","link":"/tags/Win10/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"httpd","slug":"httpd","link":"/tags/httpd/"},{"name":"Wekan","slug":"Wekan","link":"/tags/Wekan/"},{"name":"crontab","slug":"crontab","link":"/tags/crontab/"},{"name":"Cerbot","slug":"Cerbot","link":"/tags/Cerbot/"},{"name":"Let&#39;s Encrypt","slug":"Let-s-Encrypt","link":"/tags/Let-s-Encrypt/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"general_log","slug":"general-log","link":"/tags/general-log/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"cat","slug":"cat","link":"/tags/cat/"},{"name":"awk","slug":"awk","link":"/tags/awk/"},{"name":"find","slug":"find","link":"/tags/find/"},{"name":"exec","slug":"exec","link":"/tags/exec/"},{"name":"xargs","slug":"xargs","link":"/tags/xargs/"},{"name":"networksetup","slug":"networksetup","link":"/tags/networksetup/"},{"name":"Wi-Fi","slug":"Wi-Fi","link":"/tags/Wi-Fi/"},{"name":"open","slug":"open","link":"/tags/open/"},{"name":"Big Sur","slug":"Big-Sur","link":"/tags/Big-Sur/"},{"name":"Karabiner-Elements","slug":"Karabiner-Elements","link":"/tags/Karabiner-Elements/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"iStat Menus","slug":"iStat-Menus","link":"/tags/iStat-Menus/"},{"name":"kernel_task","slug":"kernel-task","link":"/tags/kernel-task/"},{"name":"displayplacer","slug":"displayplacer","link":"/tags/displayplacer/"},{"name":"transfer.sh","slug":"transfer-sh","link":"/tags/transfer-sh/"},{"name":"pbcopy","slug":"pbcopy","link":"/tags/pbcopy/"},{"name":"pbpaste","slug":"pbpaste","link":"/tags/pbpaste/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"WebStorm","slug":"WebStorm","link":"/tags/WebStorm/"},{"name":"forever","slug":"forever","link":"/tags/forever/"},{"name":"Spread operator","slug":"Spread-operator","link":"/tags/Spread-operator/"},{"name":"n","slug":"n","link":"/tags/n/"},{"name":"Rest","slug":"Rest","link":"/tags/Rest/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"ES9","slug":"ES9","link":"/tags/ES9/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"BFF","slug":"BFF","link":"/tags/BFF/"},{"name":"Gulp","slug":"Gulp","link":"/tags/Gulp/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"SQL Server 2019","slug":"SQL-Server-2019","link":"/tags/SQL-Server-2019/"},{"name":"Visual Studio","slug":"Visual-Studio","link":"/tags/Visual-Studio/"},{"name":"Sourcetree","slug":"Sourcetree","link":"/tags/Sourcetree/"},{"name":"Skyline","slug":"Skyline","link":"/tags/Skyline/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Hexo","slug":"Blog/Hexo","link":"/categories/Blog/Hexo/"},{"name":"DB","slug":"DB","link":"/categories/DB/"},{"name":"Git LFS","slug":"Git/Git-LFS","link":"/categories/Git/Git-LFS/"},{"name":"GoLand","slug":"Go/GoLand","link":"/categories/Go/GoLand/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Xcode","slug":"iOS/Xcode","link":"/categories/iOS/Xcode/"},{"name":"SQL Server","slug":"DB/SQL-Server","link":"/categories/DB/SQL-Server/"},{"name":"PowerShell","slug":"Windows/PowerShell","link":"/categories/Windows/PowerShell/"},{"name":"Computer Basics","slug":"Computer-Basics","link":"/categories/Computer-Basics/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Discrete mathematics","slug":"Math/Discrete-mathematics","link":"/categories/Math/Discrete-mathematics/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Apache","slug":"Apache","link":"/categories/Apache/"},{"name":"MySQL","slug":"DB/MySQL","link":"/categories/DB/MySQL/"},{"name":"Go语言入门到精通","slug":"Go/Go语言入门到精通","link":"/categories/Go/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"GitHub","slug":"GitHub","link":"/categories/GitHub/"}]}